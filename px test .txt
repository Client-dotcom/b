print("PhantomXOnTopForever")

-- Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„ØµØ­ÙŠØ­Ø© Ù„ØªØ­Ù…ÙŠÙ„ WindUI
local success, result = pcall(function()
    local source = game:HttpGet("https://raw.githubusercontent.com/Footagesus/WindUI/main/dist/main.lua", true)
    if source then
        local loaded = loadstring(source)
        if loaded then
            return loaded()
        end
    end
    return nil
end)



if success and result then
    
    local WindUI = result
    
    -- =============================================
    -- Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø³ÙƒØ±Ø¨Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
    -- =============================================
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local Lighting = game:GetService("Lighting")
    local TweenService = game:GetService("TweenService")
    local UserInputService = game:GetService("UserInputService")
    local StatsService = game:GetService("Stats")
    local TeleportService = game:GetService("TeleportService")
    local player = Players.LocalPlayer

    WindUI.TransparencyValue = 0.5
    WindUI:SetTheme("Dark")

-- Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¨ÙˆØ¨ Ø£Ø¨ Ø§Ù„ØªØ±Ø­ÙŠØ¨ÙŠØ©
WindUI:Popup({
    Title = "PhantomXPro",
    Icon = "crown",
    Content = "âš ï¸ ØªÙ†Ø¨ÙŠÙ‡ Ù‡Ø§Ù…:\nØªØ´ØºÙŠÙ„ Ø§Ù„Ø³ÙƒØ±Ø¨Øª ÙŠÙƒÙˆÙ† Ø¹Ù„Ù‰ Ù…Ø³Ø¤ÙˆÙ„ÙŠØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ© ÙˆØ§Ù„ÙƒØ§Ù…Ù„Ø©ØŒ ÙˆÙ†Ø­Ù† ØºÙŠØ± Ù…Ø³Ø¤ÙˆÙ„ÙŠÙ† Ø¹Ù† Ø£ÙŠ Ø¶Ø±Ø±. Ù…Ø¹ Ø£Ù†Ù†Ø§ Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªÙ‚Ø¯ÙŠÙ… Ø³ÙƒØ±Ø¨Øª Ø¨Ø£Ø¹Ù„Ù‰ Ù…Ø¹Ø§ÙŠÙŠØ± Ø§Ù„Ø£Ù…Ø§Ù† Ø§Ù„Ù…Ù…ÙƒÙ†Ø©ØŒ Ù‡Ø°Ø§ ØªØ­Ø°ÙŠØ± Ø§Ø­ØªØ±Ø§Ø·ÙŠ ÙÙŠ Ø­Ø§Ù„ Ø­Ø¯ÙˆØ« Ø£ÙŠ Ù…Ø´ÙƒÙ„Ø© ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹Ø©.Ù†ØªÙ…Ù†ÙŠ Ù„ÙƒÙ… ØªØ¬Ø±Ø¨Ø© Ù…Ù…ØªØ¹Ø© â¤",
    Buttons = {
        {
            Title = "Ù…ÙˆØ§ÙÙ‚",
            Icon = "arrow-right",
            Variant = "Primary",
            Callback = function() end
        }
    }
})

-- Ù†Ø§ÙØ°Ø© Discord Ø§Ù„Ù…Ù†Ø¨Ø«Ù‚Ø© (ÙŠØ¬Ø¨ Ø§Ù„Ø¶ØºØ· Ø¹Ù„ÙŠÙ‡Ø§ Ø¹Ø´Ø§Ù† Ø§Ù„Ø³ÙƒØ±Ø¨Øª ÙŠÙƒÙ…Ù„)
task.wait(5)
WindUI:Popup({
    Title = "ğŸ® Ø§Ù†Ø¶Ù… Ù„Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯",
    Icon = "message-circle",
    Content = "Ø§Ù†Ø¶Ù… Ù„Ù„Ø³ÙŠØ±Ú¤Ø± Ø§Ù„Ø±Ø³Ù…ÙŠ Ù„Ù„Ø³ÙƒØ±Ø¨Øª!\nâ€¢ Ø¢Ø®Ø± Ø§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª\nâ€¢ Ù…Ø³Ø§Ø¹Ø¯Ø© ÙÙ†ÙŠØ©\nâ€¢ Ø¥Ù‚ØªØ±Ø§Ø­Ø§Øª ÙˆØªØ­Ø³ÙŠÙ†Ø§Øª\nâ€¢ ØªØ­Ø¯ÙŠØ«Ø§Øª Ø£Ù…Ø§Ù†\n\nØ§Ù„Ø±Ø§Ø¨Ø·: https://discord.gg/CgUa36sPNs",
    Buttons = {
        {
            Title = "Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø· ÙˆØªÙØ¹ÙŠÙ„ Ø§Ù„Ø³ÙƒØ±Ø¨Øª",
            Icon = "copy",
            Variant = "Primary",
            Callback = function()
                -- Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø·
                setclipboard("https://discord.gg/CgUa36sPNs")
                
                WindUI:Notify({
                    Title = "âœ… ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø·",
                    Content = "ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø³ÙƒØ±Ø¨Øª!\nØ±Ø§Ø¨Ø· Ø§Ù„Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯ ÙÙŠ Ø§Ù„Ø­Ø§ÙØ¸Ø©",
                    Duration = 4
                })
            end
        }
    }
})
    -- Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø¨Ø­Ø¬Ù… Ø£ÙƒØ¨Ø±
    local Window = WindUI:CreateWindow({
        Title = "PhantomXPro",
        Icon = "crown", 
        Author = "By_Cypher",
        Folder = "PhantomXPro",
        Size = UDim2.fromOffset(800, 650),
        Theme = "Dark",
        User = {
            Enabled = true,
            Anonymous = false,
            Callback = function()
                WindUI:Notify({
                    Title = "Ù…Ø¹Ù„ÙˆÙ…Ø§ØªÙƒ",
                    Content = "Ø§Ø³Ù…Ùƒ: " .. player.Name,
                    Duration = 3
                })
            end
        },
        SideBarWidth = 250,
        ScrollBarEnabled = true
    })

    -- Ø§Ù„Ø£Ù‚Ø³Ø§Ù… Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©
    local Sections = {
        Main = Window:Section({ Title = "Main Features", Opened = true }),
        Settings = Window:Section({ Title = "Settings", Opened = true })
    }

    -- Ø§Ù„ØªØ¨ÙˆÙŠØ¨Ø§Øª
    local Tabs = {
        Info = Sections.Main:Tab({ Title = "info", Icon = "info" }),
        Teleport = Sections.Main:Tab({ Title = "Teleport", Icon = "navigation" }),
        Movement = Sections.Main:Tab({ Title = "Movement", Icon = "move" }),
        Visuals = Sections.Main:Tab({ Title = "Visuals", Icon = "eye" }),
        Other = Sections.Main:Tab({ Title = "Other", Icon = "box" }),
        ProXFeatures = Sections.Main:Tab({ Title = "ProXFeatures", Icon = "zap" }),
        Config = Sections.Settings:Tab({ Title = "Settings", Icon = "settings" }),
        Credits = Sections.Settings:Tab({ Title = "Developer", Icon = "user" })
    }

    -- =============================================
    -- ØªØ¨ÙˆÙŠØ¨ Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª  
    -- =============================================
    do
        -- Ø¯Ø§Ù„Ø© Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ©
        local function getRealStat(statName)
            local leaderstats = player:FindFirstChild("leaderstats")
            if leaderstats then
                local stat = leaderstats:FindFirstChild(statName)
                if stat then
                    return tostring(stat.Value)
                end
            end
            
            local statsFolder = player:FindFirstChild("Stats")
            if statsFolder then
                local stat = statsFolder:FindFirstChild(statName)
                if stat then
                    return tostring(stat.Value)
                end
            end
            
            return "0"
        end

        -- Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø­Ø³Ø§Ø¨
        Tabs.Info:Button({
            Title = "ğŸ‘¤ Ø§Ø³Ù…Ùƒ: " .. player.DisplayName,
            Callback = function() end
        })
        
        Tabs.Info:Button({
            Title = "ğŸ« ÙŠÙˆØ²Ø±Ùƒ: " .. player.Name,
            Callback = function() end
        })
        
        Tabs.Info:Button({
            Title = "id:" .. player.UserId,
            Callback = function() end
        })
        
        Tabs.Info:Button({
            Title = "ğŸ“… Ø¹Ù…Ø± Ø§Ù„Ø­Ø³Ø§Ø¨: " .. player.AccountAge .. " ÙŠÙˆÙ…",
            Callback = function() end
        })
        
        Tabs.Info:Button({
            Title = "âš¡ Ø§Ù„Ù‡Ø§Ùƒ: " .. (identifyexecutor and identifyexecutor() or "Ø³Ø§ÙŠÙ†Ø§Ø¨Ø³"),
            Callback = function() end
        })

        -- Ø®Ø· ÙØ§ØµÙ„
        Tabs.Info:Divider({Title = ""})

        -- Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª
        local winsBtn = Tabs.Info:Button({
            Title = "ğŸ† ÙÙˆØ²Ø§ØªÙƒ: " .. getRealStat("Wins"),
            Callback = function() end
        })
        
        local killsBtn = Tabs.Info:Button({
            Title = "âš”ï¸ Ù‚ØªÙ„Ø§ØªÙƒ: " .. getRealStat("Kills"),
            Callback = function() end
        })

        -- Ø®Ø· ÙØ§ØµÙ„
        Tabs.Info:Divider({Title = ""})

        -- Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠØ±ÙØ±
        local playersBtn = Tabs.Info:Button({
            Title = "ğŸ‘¥ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†: " .. #Players:GetPlayers(),
            Callback = function() end
        })
        
        local fpsBtn = Tabs.Info:Button({
            Title = "ğŸ“Š ÙØ±ÙŠÙ…Ø§ØªÙƒ: ÙŠØ­Ø³Ø¨...",
            Callback = function() end
        })
        
        local pingBtn = Tabs.Info:Button({
            Title = "ğŸ“¡ Ø§Ù„Ø¨ÙŠÙ†Ù‚: ÙŠØ­Ø³Ø¨...",
            Callback = function() end
        })

        -- Ø®Ø· ÙØ§ØµÙ„
        Tabs.Info:Divider({Title = ""})

        -- Ø²Ø± Rejoin
        Tabs.Info:Button({
            Title = "Ø§Ø¯Ø®Ù„ Ù†ÙØ³ Ø³ÙŠØ±ÙØ±Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: Rejoin",
            Callback = function()
                local currentServerId = game.JobId
                
                WindUI:Notify({
                    Title = "Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„",
                    Content = "Ø¨ÙŠØ®Ø±Ø¬Ùƒ ÙˆÙŠØ¯Ø®Ù„Ùƒ Ù†ÙØ³ Ø§Ù„Ø³ÙŠØ±ÙØ±...",
                    Duration = 3
                })
                
                wait(1)
                
                local placeId = game.PlaceId
                local jobId = game.JobId
                
                pcall(function()
                    TeleportService:TeleportToPlaceInstance(placeId, jobId, player)
                end)
            end
        })

        -- Ø²Ø± Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£ÙØ¶Ù„ Ø³ÙŠØ±ÙØ±
        Tabs.Info:Button({
            Title = "ğŸš€ Ø§Ø¨Ø­Ø« Ø¹Ù† Ø³ÙŠØ±ÙØ± Ø³Ø±ÙŠØ¹",
            Callback = function()
                local HttpService = game:GetService("HttpService")
                
                WindUI:Notify({
                    Title = "Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø«",
                    Content = "Ø¨Ø¯ÙˆØ± Ø¹Ù„Ù‰ Ø³ÙŠØ±ÙØ±...",
                    Duration = 5
                })
                
                local function teleportToRandomServer()
                    local placeId = game.PlaceId
                    pcall(function()
                        TeleportService:Teleport(placeId, player)
                    end)
                end
                
                local function tryFindServer()
                    local placeId = game.PlaceId
                    local url = "https://games.roblox.com/v1/games/" .. placeId .. "/servers/Public?limit=10"
                    
                    local success, result = pcall(function()
                        local response = game:HttpGet(url)
                        return HttpService:JSONDecode(response)
                    end)
                    
                    if success and result and result.data then
                        for _, server in pairs(result.data) do
                            if server.id and server.playing < server.maxPlayers then
                                WindUI:Notify({
                                    Title = "ÙˆØ¬Ø¯Ù†Ø§ Ø³ÙŠØ±ÙØ±!",
                                    Content = "Ø¨ÙŠØªÙ‚Ù„ Ø§Ù„Ø¢Ù†...",
                                    Duration = 3
                                })
                                
                                wait(1)
                                TeleportService:TeleportToPlaceInstance(placeId, server.id, player)
                                return
                            end
                        end
                    end
                    
                    WindUI:Notify({
                        Title = "Ù…Ø§ Ù„Ù‚ÙŠÙ†Ø§",
                        Content = "Ø¨Ù†Ù†ØªÙ‚Ù„ Ø¹Ø´ÙˆØ§Ø¦ÙŠØ§Ù‹...",
                        Duration = 3
                    })
                    wait(2)
                    teleportToRandomServer()
                end
                
                tryFindServer()
            end
        })

        -- ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¹Ù„ÙˆÙ…Ø§Øª
        spawn(function()
            while true do
                wait(3)
                winsBtn:SetTitle("ğŸ† ÙÙˆØ²Ø§ØªÙƒ: " .. getRealStat("Wins"))
                killsBtn:SetTitle("âš”ï¸ Ù‚ØªÙ„Ø§ØªÙƒ: " .. getRealStat("Kills"))
                playersBtn:SetTitle("ğŸ‘¥ Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ†: " .. #Players:GetPlayers())
                
                pcall(function()
                    local ping = StatsService.Network.ServerStatsItem["Data Ping"]:GetValue()
                    pingBtn:SetTitle("ğŸ“¡ Ø§Ù„Ø¨ÙŠÙ†Ù‚: " .. math.floor(ping) .. " ms")
                end)
            end
        end)

        local frameCount = 0
        local lastTime = tick()
        RunService.RenderStepped:Connect(function()
            frameCount = frameCount + 1
            local currentTime = tick()
            if currentTime - lastTime >= 1 then
                local fps = math.floor(frameCount / (currentTime - lastTime))
                frameCount = 0
                lastTime = currentTime
                fpsBtn:SetTitle("ğŸ“Š ÙØ±ÙŠÙ…Ø§ØªÙƒ: " .. fps)
            end
        end)
    end

    -- =============================================
    -- Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ÙˆØªÙˆ Ø¬ÙˆÙŠÙ† Ø§Ù„ÙƒØ§Ù…Ù„
    -- =============================================
    do
        Tabs.Teleport:Paragraph({
            Title = "Auto Join Arena",
            Desc = "Automatically Join Arenas",
            Image = "users",
            ImageSize = 28,
            Color = Color3.fromRGB(0, 200, 255)
        })

        local AutoJoinEnabled = false
        local JoinMode = "Ø¹Ø¯ÙˆÙ‰"
        local TargetPlayer = "Ø§Ù„ÙƒÙ„"
        local SelectedArena = "Ø£ÙŠ Ø³Ø§Ø­Ø©"
        local ShowArenaESP = true
        local arenaESP = nil
        local autoJoinConnection = nil

        local function getAllPlayerNames()
            local players = {"Ø§Ù„ÙƒÙ„"}
            for _, plr in pairs(game.Players:GetPlayers()) do
                if plr ~= player then
                    table.insert(players, plr.Name)
                end
            end
            return players
        end

        local function teleportToWorldSpawn()
            local character = player.Character
            if character and character:FindFirstChild("HumanoidRootPart") and workspace:FindFirstChild("WorldSpawn") then
                local humanoidRootPart = character.HumanoidRootPart
                local worldSpawn = workspace.WorldSpawn
                humanoidRootPart.CFrame = worldSpawn.CFrame
                return true
            end
            return false
        end

        local function createArenaESP()
            if arenaESP and arenaESP.Parent then
                arenaESP:Destroy()
                arenaESP = nil
            end
            
            if SelectedArena == "Ø£ÙŠ Ø³Ø§Ø­Ø©" or not ShowArenaESP then
                return
            end
            
            local targetArena = workspace.Arenas:FindFirstChild(SelectedArena)
            if not targetArena then
                return
            end
            
            arenaESP = Instance.new("Highlight")
            arenaESP.Name = "SelectedArenaESP"
            arenaESP.FillColor = Color3.fromRGB(0, 255, 0)
            arenaESP.FillTransparency = 0.8
            arenaESP.OutlineColor = Color3.fromRGB(255, 255, 0)
            arenaESP.OutlineTransparency = 0
            arenaESP.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
            
            arenaESP.Parent = targetArena
            
            local espLabel = Instance.new("BillboardGui")
            espLabel.Name = "ArenaLabel"
            espLabel.Size = UDim2.new(0, 200, 0, 50)
            espLabel.StudsOffset = Vector3.new(0, 10, 0)
            espLabel.AlwaysOnTop = true
            espLabel.Adornee = targetArena
            
            local labelText = Instance.new("TextLabel")
            labelText.Size = UDim2.new(1, 0, 1, 0)
            labelText.BackgroundTransparency = 1
            labelText.Text = "Ø§Ù„Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©\n[" .. SelectedArena .. "]"
            labelText.TextColor3 = Color3.fromRGB(255, 255, 0)
            labelText.TextSize = 14
            labelText.Font = Enum.Font.GothamBold
            labelText.TextStrokeTransparency = 0
            labelText.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
            
            labelText.Parent = espLabel
            espLabel.Parent = targetArena
        end

        local function removeArenaESP()
            if arenaESP and arenaESP.Parent then
                arenaESP:Destroy()
                arenaESP = nil
            end
            
            if workspace.Arenas then
                for _, arena in pairs(workspace.Arenas:GetChildren()) do
                    local label = arena:FindFirstChild("ArenaLabel")
                    if label then
                        label:Destroy()
                    end
                end
            end
        end

        local function isPlayerInsideHull(arena, side, slotNum)
            local character = player.Character
            if not character or not character:FindFirstChild("HumanoidRootPart") then
                return false
            end
            
            local slot = arena.Slots[side]:FindFirstChild(tostring(slotNum))
            if not slot or not slot:FindFirstChild("Hull") then
                return false
            end
            
            local hull = slot.Hull
            local playerPosition = character.HumanoidRootPart.Position
            local hullPosition = hull.Position
            local hullSize = hull.Size
            
            local distance = (playerPosition - hullPosition).Magnitude
            local maxDistance = math.max(hullSize.X, hullSize.Y, hullSize.Z) / 2 + 2
            
            return distance <= maxDistance
        end

        local function isPadStillValid(arena, side, slotNum)
            local slot = arena.Slots[side]:FindFirstChild(tostring(slotNum))
            if not slot then return false end
            
            local pad = slot:FindFirstChild("Pad")
            if not pad then return false end
            
            return pad.Transparency < 1 and pad.Parent ~= nil
        end

        local function checkPlayerArenaStatus()
            if workspace:FindFirstChild("Arenas") then
                for _, arena in pairs(workspace.Arenas:GetChildren()) do
                    if arena:FindFirstChild("Slots") then
                        for _, side in pairs({"Left", "Right"}) do
                            if arena.Slots:FindFirstChild(side) then
                                for i = 1, 4 do
                                    local slot = arena.Slots[side]:FindFirstChild(tostring(i))
                                    if slot and slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") then
                                        if slot.Data.Player.Value == player then
                                            local isInside = isPlayerInsideHull(arena, side, i)
                                            return true, arena, side, i, isInside
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
            return false, nil, nil, nil, false
        end

        local function handlePadDisappearance()
            local isInArena, arena, side, slot = checkPlayerArenaStatus()
            if isInArena then
                if not isPadStillValid(arena, side, slot) then
                    teleportToWorldSpawn()
                    return true
                end
            end
            return false
        end

        local function pressReadyButton()
            local remoteStorage = game:GetService("ReplicatedStorage")
            if remoteStorage:FindFirstChild("Remotes") and remoteStorage.Remotes:FindFirstChild("Arena") 
            and remoteStorage.Remotes.Arena:FindFirstChild("Ready") then
                pcall(function()
                    remoteStorage.Remotes.Arena.Ready:FireServer(true)
                end)
                return true
            end
            
            local playerGui = player:FindFirstChild("PlayerGui")
            if playerGui and playerGui:FindFirstChild("TBDUI") then
                local main = playerGui.TBDUI:FindFirstChild("Main")
                if main then
                    local prompts = main:FindFirstChild("Prompts")
                    if prompts then
                        local readyButton = prompts:FindFirstChild("Ready")
                        if readyButton and readyButton:IsA("TextButton") and readyButton.Visible then
                            pcall(function()
                                readyButton:FireServer("MouseButton1Click")
                            end)
                            pcall(function()
                                readyButton:Activate()
                            end)
                            return true
                        end
                    end
                end
            end
            return false
        end

        local function isSlotInGame(arena, side, slotNum)
            local slot = arena.Slots[side]:FindFirstChild(tostring(slotNum))
            if slot and slot:FindFirstChild("Pad") then
                local pad = slot.Pad
                local color = pad.Color
                if math.abs(color.R - 87/255) < 0.01 and 
                   math.abs(color.G - 181/255) < 0.01 and 
                   math.abs(color.B - 57/255) < 0.01 then
                    return true
                end
            end
            return false
        end

        local function isAnyPlayerInGameInArena(arena)
            if not arena or not arena:FindFirstChild("Slots") then
                return false
            end
            
            for _, side in pairs({"Left", "Right"}) do
                if arena.Slots:FindFirstChild(side) then
                    for i = 1, 4 do
                        if isSlotInGame(arena, side, i) then
                            return true
                        end
                    end
                end
            end
            
            return false
        end

        local function findEmptyPadInArena(arena, preferredSide)
            if not arena or not arena:FindFirstChild("Slots") then
                return nil, nil
            end
            
            if preferredSide and arena.Slots:FindFirstChild(preferredSide) then
                for i = 1, 4 do
                    local slot = arena.Slots[preferredSide]:FindFirstChild(tostring(i))
                    if slot and slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") then
                        if slot.Data.Player.Value == nil and not isSlotInGame(arena, preferredSide, i) then
                            return preferredSide, i
                        end
                    end
                end
            end
            
            for _, side in pairs({"Left", "Right"}) do
                if arena.Slots:FindFirstChild(side) then
                    for i = 1, 4 do
                        local slot = arena.Slots[side]:FindFirstChild(tostring(i))
                        if slot and slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") then
                            if slot.Data.Player.Value == nil and not isSlotInGame(arena, side, i) then
                                return side, i
                            end
                        end
                    end
                end
            end
            
            return nil, nil
        end

        local function joinArenaSlot(arena, targetSide, targetSlot)
            if not arena.Slots[targetSide]:FindFirstChild(tostring(targetSlot)) or 
               not arena.Slots[targetSide][tostring(targetSlot)]:FindFirstChild("Hull") then
                return false
            end
            
            local hull = arena.Slots[targetSide][tostring(targetSlot)].Hull
            local character = player.Character
            if character and character:FindFirstChild("HumanoidRootPart") then
                character.HumanoidRootPart.CFrame = hull.CFrame + Vector3.new(0, 5, 0)
                
                task.wait(0.3)
                
                if isPlayerInsideHull(arena, targetSide, targetSlot) then
                    return true
                else
                    return false
                end
            end
            return false
        end

        local function findFirstAvailableSlot(arena, side, excludeSlot)
            if not arena or not arena.Slots or not arena.Slots:FindFirstChild(side) then
                return nil
            end
            
            for i = 1, 4 do
                if i ~= excludeSlot then
                    local slot = arena.Slots[side]:FindFirstChild(tostring(i))
                    if slot and slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") then
                        if slot.Data.Player.Value == nil and not isSlotInGame(arena, side, i) then
                            return i
                        end
                    end
                end
            end
            
            return nil
        end

        function findTargetPlayer(targetName)
            if targetName == "Ø§Ù„ÙƒÙ„" then
                return nil
            end
            
            for _, plr in pairs(game.Players:GetPlayers()) do
                if plr.Name == targetName and plr ~= player then
                    return plr
                end
            end
            return nil
        end

        function isInGame()
            local playerGui = player:FindFirstChild("PlayerGui")
            if playerGui and playerGui:FindFirstChild("TBDUI") and playerGui.TBDUI:FindFirstChild("Main") and playerGui.TBDUI.Main:FindFirstChild("Scorebar") then
                return playerGui.TBDUI.Main.Scorebar.Visible
            end
            return false
        end

        function findPlayerInArenas(targetPlayer)
            if workspace.Arenas then
                local availablePlayers = {}
                
                for _, arena in pairs(workspace.Arenas:GetChildren()) do
                    if SelectedArena ~= "Ø£ÙŠ Ø³Ø§Ø­Ø©" and arena.Name ~= SelectedArena then
                        continue
                    end
                    
                    if arena:FindFirstChild("Slots") then
                        if isAnyPlayerInGameInArena(arena) then
                            continue
                        end
                        
                        for _, side in pairs({"Left", "Right"}) do
                            if arena.Slots:FindFirstChild(side) then
                                for i = 1, 4 do
                                    local slot = arena.Slots[side]:FindFirstChild(tostring(i))
                                    if slot and slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") then
                                        local plr = slot.Data.Player.Value
                                        if plr and plr ~= player and plr.Parent and not isSlotInGame(arena, side, i) then
                                            local hasAvailableSlot = false
                                            
                                            if JoinMode == "Ø¹Ø¯ÙˆÙ‰" then
                                                local oppositeSide = (side == "Left") and "Right" or "Left"
                                                if findFirstAvailableSlot(arena, oppositeSide, nil) then
                                                    hasAvailableSlot = true
                                                end
                                            elseif JoinMode == "ÙØ±ÙŠÙ‚" then
                                                if findFirstAvailableSlot(arena, side, i) then
                                                    hasAvailableSlot = true
                                                end
                                            end
                                            
                                            if hasAvailableSlot then
                                                if targetPlayer == nil then
                                                    table.insert(availablePlayers, {
                                                        arena = arena,
                                                        side = side,
                                                        slot = i,
                                                        player = plr
                                                    })
                                                elseif plr == targetPlayer then
                                                    return arena, side, i, plr
                                                end
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
                
                if targetPlayer == nil and #availablePlayers > 0 then
                    local selected = availablePlayers[1]
                    return selected.arena, selected.side, selected.slot, selected.player
                end
            end
            return nil
        end

        function findBestSlot(arena, foundSide, foundSlot, foundPlayer)
            if isAnyPlayerInGameInArena(arena) then
                return nil, nil
            end
            
            local targetSide = foundSide
            local targetSlot = foundSlot
            
            if JoinMode == "Ø¹Ø¯ÙˆÙ‰" then
                targetSide = (foundSide == "Left") and "Right" or "Left"
                local emptySide, emptySlot = findEmptyPadInArena(arena, targetSide)
                if emptySide and emptySlot then
                    return emptySide, emptySlot
                end
            elseif JoinMode == "ÙØ±ÙŠÙ‚" then
                targetSide = foundSide
                local emptySide, emptySlot = findEmptyPadInArena(arena, targetSide)
                if emptySide and emptySlot then
                    return emptySide, emptySlot
                end
            end
            
            return nil, nil
        end

        function isReadyPromptVisible()
            local playerGui = player:FindFirstChild("PlayerGui")
            if playerGui and playerGui:FindFirstChild("TBDUI") and playerGui.TBDUI:FindFirstChild("Main") 
            and playerGui.TBDUI.Main:FindFirstChild("Prompts") and playerGui.TBDUI.Main.Prompts:FindFirstChild("Ready") then
                return playerGui.TBDUI.Main.Prompts.Ready.Visible, playerGui.TBDUI.Main.Prompts.Ready
            end
            return false, nil
        end

        function startAutoJoinLoop()
            if autoJoinConnection then
                autoJoinConnection:Disconnect()
            end
            
            autoJoinConnection = RunService.Heartbeat:Connect(function()
                if not AutoJoinEnabled then return end
                
                if handlePadDisappearance() then
                    return
                end
                
                if isInGame() then
                    return
                end
                
                local isInArena, currentArena, currentSide, currentSlot, isInsideHull = checkPlayerArenaStatus()
                
                if isInArena then
                    if not isInsideHull then
                        joinArenaSlot(currentArena, currentSide, currentSlot)
                        return
                    end
                    
                    local playersInCurrentArena = {}
                    if currentArena and currentArena:FindFirstChild("Slots") then
                        for _, side in pairs({"Left", "Right"}) do
                            if currentArena.Slots:FindFirstChild(side) then
                                for i = 1, 4 do
                                    local slot = currentArena.Slots[side]:FindFirstChild(tostring(i))
                                    if slot and slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") and slot.Data.Player.Value then
                                        local plr = slot.Data.Player.Value
                                        if plr ~= player and plr.Parent and not isSlotInGame(currentArena, side, i) then
                                            table.insert(playersInCurrentArena, plr)
                                        end
                                    end
                                end
                            end
                        end
                    end

                    if #playersInCurrentArena == 0 then
                        teleportToWorldSpawn()
                        return
                    end

                    local readyVisible, readyPrompt = isReadyPromptVisible()
                    if readyVisible and readyPrompt and readyPrompt.Text == "Ready" then
                        pressReadyButton()
                    end
                    return
                end
                
                local foundArena, foundSide, foundSlot, foundPlayer
                if TargetPlayer == "Ø§Ù„ÙƒÙ„" then
                    foundArena, foundSide, foundSlot, foundPlayer = findPlayerInArenas(nil)
                else
                    local targetPlr = findTargetPlayer(TargetPlayer)
                    if targetPlr and targetPlr.Parent then 
                        foundArena, foundSide, foundSlot, foundPlayer = findPlayerInArenas(targetPlr)
                    end
                end
                
                if foundArena and foundSide and foundSlot then
                    local targetSide, targetSlot = findBestSlot(foundArena, foundSide, foundSlot, foundPlayer)
                    
                    if targetSide and targetSlot then
                        joinArenaSlot(foundArena, targetSide, targetSlot)
                    end
                end
            end)
        end

        Tabs.Teleport:Toggle({
            Title = "Ø´ØºÙ‘Ù„ Ø§Ù„Ø£ÙˆØªÙˆ Ø¬ÙˆÙŠÙ†",
            Desc = "Ø·ÙÙŠÙ‡ Ø§Ø°Ø§ Ø¨ØªØ¯Ø®Ù„ Ø§Ù†Øª Ø¨ÙŠØ¯Ùƒ Ù…Ø¨ Ø§ÙˆØªÙˆ",
            Value = false,
            Size = "xlarge",
            Callback = function(state)
                AutoJoinEnabled = state
                if state then
                    startAutoJoinLoop()
                else
                    if autoJoinConnection then
                        autoJoinConnection:Disconnect()
                        autoJoinConnection = nil
                    end
                end
            end
        })

        Tabs.Teleport:Dropdown({
            Title = "Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯Ø®ÙˆÙ„",
            Values = {"Ø¹Ø¯ÙˆÙ‰", "ÙØ±ÙŠÙ‚"},
            Value = "Ø¹Ø¯ÙˆÙ‰",
            Size = "xlarge",
            Callback = function(value)
                JoinMode = value
            end
        })

        Tabs.Teleport:Dropdown({
            Title = "Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø§Ù„Ù…Ø³ØªÙ‡Ø¯Ù",
            Values = getAllPlayerNames(),
            Value = "Ø§Ù„ÙƒÙ„",
            Size = "xlarge",
            Callback = function(value)
                TargetPlayer = value
            end
        })

        Tabs.Teleport:Dropdown({
            Title = "Ø§Ø®ØªØ§Ø± Ø§Ù„Ø³Ø§Ø­Ø©",
            Values = {"Ø£ÙŠ Ø³Ø§Ø­Ø©", "Arena1", "Arena2", "Arena3", "Arena4", "Arena5", "Arena6", "Arena5ICED"},
            Value = "Ø£ÙŠ Ø³Ø§Ø­Ø©",
            Size = "xlarge",
            Callback = function(value)
                SelectedArena = value
                removeArenaESP()
                if value ~= "Ø£ÙŠ Ø³Ø§Ø­Ø©" then
                    createArenaESP()
                end
            end
        })

        Tabs.Teleport:Toggle({
            Title = "Ø§Ø¸Ù‡Ø± Ø§Ù„Ø³Ø§Ø­Ø© Ø§Ù„Ù…Ø®ØªØ§Ø±Ø©",
            Desc = "Ø¨ÙŠØ¸Ù‡Ø± Ù„Ùƒ Ø§Ù„Ø³Ø§Ø­Ø© Ø§Ù„Ù„ÙŠ Ø§Ø®ØªØ±ØªÙ‡Ø§",
            Value = true,
            Size = "xlarge",
            Callback = function(state)
                ShowArenaESP = state
                if state then
                    createArenaESP()
                else
                    removeArenaESP()
                end
            end
        })

        Tabs.Teleport:Divider()

        -- Ø£Ø¯ÙˆØ§Øª Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„Ø£Ø®Ø±Ù‰
        Tabs.Teleport:Paragraph({
            Title = "Teleport Tools",
            Desc = "Teleport anywhere quickly",
            Image = "navigation",
            ImageSize = 28,
            Color = "White"
        })

        local lastPosition = nil

        local function teleportToPosition(cframePosition)
            local character = player.Character
            if character and cframePosition then
                local hrp = character:FindFirstChild("HumanoidRootPart")
                local hum = character:FindFirstChild("Humanoid")
                if hrp and hum then
                    hum.PlatformStand = true
                    local startPos = hrp.Position
                    local endPos = cframePosition.Position
                    local steps = 10

                    for i = 1, steps do
                        local alpha = i / steps
                        local interpPos = startPos:Lerp(endPos, alpha)
                        hrp.CFrame = CFrame.new(interpPos)
                        task.wait(0.01)
                    end

                    hrp.CFrame = cframePosition
                    task.wait(0.1)
                    hum.PlatformStand = false
                    return true
                end
            end
            return false
        end

        local function teleportToNearestEnemy()
            local char = player.Character
            local hrp = char and char:FindFirstChild("HumanoidRootPart")
            if not hrp then return false end

            local nearest, dist = nil, math.huge
            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= player and p.Character and p.Character:FindFirstChild("HumanoidRootPart") and p.Character:FindFirstChild("Humanoid") then
                    local target = p.Character
                    if target.Humanoid.Health > 0 then
                        local d = (hrp.Position - target.HumanoidRootPart.Position).Magnitude
                        if d < dist then
                            dist = d
                            nearest = target
                        end
                    end
                end
            end

            if nearest then
                local direction = (nearest.HumanoidRootPart.Position - hrp.Position).Unit
                hrp.CFrame = CFrame.new(nearest.HumanoidRootPart.Position - direction * 3, nearest.HumanoidRootPart.Position)
                return true
            end
            return false
        end

        Tabs.Teleport:Button({
            Title = "Ø§Ø­ÙØ¸ Ù…ÙƒØ§Ù†ÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠ",
            Icon = "map-pin",
            Size = "xlarge",
            Callback = function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then 
                    lastPosition = hrp.CFrame
                end
            end
        })

        Tabs.Teleport:Button({
            Title = "Ø±Ø­ Ù„Ù„Ù…ÙƒØ§Ù† Ø§Ù„Ù…Ø­ÙÙˆØ¸",
            Icon = "send",
            Size = "xlarge",
            Callback = function()
                if lastPosition then
                    teleportToPosition(lastPosition)
                end
            end
        })

        Tabs.Teleport:Button({
            Title = "Ø±Ø­ ÙÙˆÙ‚ Ø§Ù„Ø®Ø±ÙŠØ·Ø©",
            Icon = "arrow-up",
            Size = "xlarge",
            Callback = function()
                local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                if hrp then 
                    hrp.CFrame = hrp.CFrame + Vector3.new(0, 100, 0)
                end
            end
        })

        Tabs.Teleport:Button({
            Title = "Ø§Ø±ÙˆØ­ Ù„Ø£Ù‚Ø±Ø¨ Ø¹Ø¯Ùˆ",
            Icon = "target",
            Size = "xlarge",
            Callback = function()
                teleportToNearestEnemy()
            end
        })
    end

-- =============================================
-- Ù†Ø¸Ø§Ù… Ø§Ù„Ø£ÙˆØªÙˆ ÙÙˆÙ„Ùˆ Ø§Ù„ÙƒØ§Ù…Ù„
-- =============================================
do
    local FOLLOW_DURATION = 8
    local MIN_DIST = 1.5
    local SCRIPT_ENABLED = false
    local SUSPEND_ON_GIVE = true
    local RECENT_OWNER_WINDOW = 1.2
    local STRAFE_DISTANCE = 5
    local STRAFE_AMPLITUDE = 1.4
    local STRAFE_SPEED = 8

    local followUntil = 0
    local bombGiver = nil
    local targetPlayer = nil
    local suspendMovement = false
    local lastHadBomb = {}
    local lockedByGame = false

    local autoFollowGUI = nil
    local autoFollowFrame = nil
    local autoFollowButton = nil
    local autoFollowPosition = UDim2.new(0, 30, 0, 30)
    local isAutoFollowLocked = false

    local function createAutoFollowGUI()
        if autoFollowGUI then autoFollowGUI:Destroy() end
        
        autoFollowGUI = Instance.new("ScreenGui")
        autoFollowGUI.Name = "PhantomXPro_Auto"
        autoFollowGUI.Parent = game.CoreGui
        autoFollowGUI.ResetOnSpawn = false

        autoFollowFrame = Instance.new("Frame")
        autoFollowFrame.Size = UDim2.new(0, 130, 0, 50)
        autoFollowFrame.Position = autoFollowPosition
        autoFollowFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
        autoFollowFrame.BackgroundTransparency = 0.2
        autoFollowFrame.BorderSizePixel = 0
        autoFollowFrame.Visible = SCRIPT_ENABLED
        autoFollowFrame.Active = true
        autoFollowFrame.Draggable = not isAutoFollowLocked
        autoFollowFrame.Parent = autoFollowGUI

        local gradient = Instance.new("UIGradient", autoFollowFrame)
        gradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(60, 60, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(180, 0, 255))
        })
        gradient.Rotation = 45

        local corner = Instance.new("UICorner", autoFollowFrame)
        corner.CornerRadius = UDim.new(0, 12)

        autoFollowButton = Instance.new("TextButton")
        autoFollowButton.Size = UDim2.new(1, -8, 1, -8)
        autoFollowButton.Position = UDim2.new(0, 4, 0, 4)
        autoFollowButton.BackgroundTransparency = 1
        autoFollowButton.Font = Enum.Font.GothamBold
        autoFollowButton.TextColor3 = Color3.new(1, 1, 1)
        autoFollowButton.TextSize = 16
        
        if isAutoFollowLocked then
            autoFollowButton.Text = SCRIPT_ENABLED and "Ø§Ù„Ø£ÙˆØªÙˆ: Ø´ØºØ§Ù„ ğŸ”’" or "Ø§Ù„Ø£ÙˆØªÙˆ: Ù…ØªÙˆÙ‚Ù ğŸ”’"
        else
            autoFollowButton.Text = SCRIPT_ENABLED and "Ø§Ù„Ø£ÙˆØªÙˆ: Ø´ØºØ§Ù„" or "Ø§Ù„Ø£ÙˆØªÙˆ: Ù…ØªÙˆÙ‚Ù"
        end
        
        autoFollowButton.Parent = autoFollowFrame

        local dragging = false
        local dragStart, startPos

        local function updateDrag(input)
            if isAutoFollowLocked then return end
            
            local delta = input.Position - dragStart
            autoFollowFrame.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
            autoFollowPosition = autoFollowFrame.Position
        end

        local function beginDrag(input)
            if isAutoFollowLocked then return end
            
            dragging = true
            dragStart = input.Position
            startPos = autoFollowFrame.Position
        end

        local function endDrag()
            dragging = false
        end

        for _, element in pairs({autoFollowFrame, autoFollowButton}) do
            element.InputBegan:Connect(function(input)
                if isAutoFollowLocked then return end
                
                if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
                    beginDrag(input)
                    input.Changed:Connect(function()
                        if input.UserInputState == Enum.UserInputState.End then
                            endDrag()
                        end
                    end)
                end
            end)
        end

        UserInputService.InputChanged:Connect(function(input)
            if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
                updateDrag(input)
            end
        end)

        local backgroundFrame = Instance.new("Frame")
        backgroundFrame.Size = UDim2.new(1, 0, 1, 0)
        backgroundFrame.BackgroundColor3 = Color3.fromRGB(255, 60, 60)
        backgroundFrame.BackgroundTransparency = 0.2
        backgroundFrame.BorderSizePixel = 0
        backgroundFrame.ZIndex = -1
        backgroundFrame.Parent = autoFollowFrame

        local backgroundCorner = Instance.new("UICorner", backgroundFrame)
        backgroundCorner.CornerRadius = UDim.new(0, 12)

        autoFollowButton.MouseButton1Click:Connect(function()
            SCRIPT_ENABLED = not SCRIPT_ENABLED
            if SCRIPT_ENABLED then
                autoFollowButton.Text = isAutoFollowLocked and "Ø§Ù„Ø£ÙˆØªÙˆ: Ø´ØºØ§Ù„ ğŸ”’" or "Ø§Ù„Ø£ÙˆØªÙˆ: Ø´ØºØ§Ù„"
                local tween = TweenService:Create(backgroundFrame, TweenInfo.new(0.5), {
                    BackgroundColor3 = Color3.fromRGB(0, 180, 255)
                })
                tween:Play()
            else
                autoFollowButton.Text = isAutoFollowLocked and "Ø§Ù„Ø£ÙˆØªÙˆ: Ù…ØªÙˆÙ‚Ù ğŸ”’" or "Ø§Ù„Ø£ÙˆØªÙˆ: Ù…ØªÙˆÙ‚Ù"
                local tween = TweenService:Create(backgroundFrame, TweenInfo.new(0.5), {
                    BackgroundColor3 = Color3.fromRGB(255, 60, 60)
                })
                tween:Play()
                targetPlayer = nil
                suspendMovement = false
            end
        end)
    end

    local function toggleAutoFollow(state)
        SCRIPT_ENABLED = state
        if SCRIPT_ENABLED then
            if not autoFollowGUI then
                createAutoFollowGUI()
            end
            if autoFollowFrame then
                autoFollowFrame.Visible = true
                autoFollowFrame.Position = autoFollowPosition
                autoFollowButton.Text = isAutoFollowLocked and "Ø§Ù„Ø£ÙˆØªÙˆ: Ø´ØºØ§Ù„ ğŸ”’" or "Ø§Ù„Ø£ÙˆØªÙˆ: Ø´ØºØ§Ù„"
            end
        else
            if autoFollowFrame then
                autoFollowPosition = autoFollowFrame.Position
                autoFollowFrame.Visible = false
                autoFollowButton.Text = isAutoFollowLocked and "Ø§Ù„Ø£ÙˆØªÙˆ: Ù…ØªÙˆÙ‚Ù ğŸ”’" or "Ø§Ù„Ø£ÙˆØªÙˆ: Ù…ØªÙˆÙ‚Ù"
            end
            targetPlayer = nil
            suspendMovement = false
        end
    end

    local function isAlive(p)
        return p and p.Character and p.Character:FindFirstChild("Humanoid") and p.Character.Humanoid.Health > 0
    end

    local function hasBomb(char)
        if not char then return false end
        return char:FindFirstChild("Bomb") ~= nil
    end

    local function hasGreenHighlight(char)
        if not char then return false end
        for _, obj in pairs(char:GetDescendants()) do
            if obj:IsA("Highlight") and math.abs(obj.FillColor.G - 1) < 0.01 then return true end
            if obj:IsA("BillboardGui") then
                local fr = obj:FindFirstChildOfClass("Frame")
                if fr and fr.BackgroundColor3 == Color3.fromRGB(0,255,0) then return true end
            end
        end
        return false
    end

    local function detectArenaForLocal()
        if workspace:FindFirstChild("Arenas") then
            for _, arena in pairs(workspace.Arenas:GetChildren()) do
                if arena:FindFirstChild("Slots") then
                    for _, side in ipairs({"Left","Right"}) do
                        local folder = arena.Slots:FindFirstChild(side)
                        if folder then
                            for i = 1,4 do
                                local slot = folder:FindFirstChild(tostring(i))
                                if slot and slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") then
                                    if slot.Data.Player.Value == player then
                                        return arena, side
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
        return nil, nil
    end

    local function getEnemiesInSameArena()
        local arena, mySide = detectArenaForLocal()
        if not arena then return {}, nil end
        local opp = (mySide == "Left") and "Right" or "Left"
        local enemies = {}
        if arena.Slots:FindFirstChild(opp) then
            for _, slot in pairs(arena.Slots[opp]:GetChildren()) do
                if slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") then
                    local p = slot.Data.Player.Value
                    if p and p ~= player then table.insert(enemies, p) end
                end
            end
        end
        return enemies, arena
    end

    local function watchCharacter(ch, plr)
        ch.ChildAdded:Connect(function(c)
            if c:IsA("Tool") and c.Name == "Bomb" then
                lastHadBomb[plr] = tick()
            end
        end)
        ch.ChildRemoved:Connect(function(c)
            if c:IsA("Tool") and c.Name == "Bomb" then
                lastHadBomb[plr] = tick()
            end
        end)
    end

    for _, p in ipairs(Players:GetPlayers()) do
        if p.Character then watchCharacter(p.Character, p) end
        p.CharacterAdded:Connect(function(c) watchCharacter(c, p) end)
    end
    Players.PlayerAdded:Connect(function(p) p.CharacterAdded:Connect(function(c) watchCharacter(c, p) end) end)

    local function guessGiver()
        local best, bt = nil, math.huge
        local now = tick()
        for p, t in pairs(lastHadBomb) do
            if p ~= player and t and (now - t) <= RECENT_OWNER_WINDOW then
                local dt = now - t
                if dt < bt then bt = dt best = p end
            end
        end
        return best
    end

    local function onLocalAdded(c)
        if c:IsA("Tool") and c.Name == "Bomb" then
            local g = guessGiver()
            if g and isAlive(g) then
                bombGiver = g
                lockedByGame = false
            else
                bombGiver = nil
                lockedByGame = true
            end
            followUntil = tick() + FOLLOW_DURATION
            suspendMovement = false
            
            if SCRIPT_ENABLED then
                targetPlayer = bombGiver
            end
        end
    end

    local function onLocalRemoved(c)
        if c:IsA("Tool") and c.Name == "Bomb" then
            targetPlayer = nil
            bombGiver = nil
            lockedByGame = false
            
            if SUSPEND_ON_GIVE then
                suspendMovement = true
            end
        end
    end

    local function connectLocal(ch)
        ch.ChildAdded:Connect(onLocalAdded)
        ch.ChildRemoved:Connect(onLocalRemoved)
    end

    if player.Character then connectLocal(player.Character) end
    player.CharacterAdded:Connect(connectLocal)

    local function resetRound()
        bombGiver = nil
        targetPlayer = nil
        followUntil = 0
        suspendMovement = false
        lockedByGame = false
    end

    if workspace:FindFirstChild("Arenas") then
        workspace.Arenas.ChildAdded:Connect(resetRound)
        workspace.Arenas.ChildRemoved:Connect(resetRound)
    end

    local function chooseClosestEnemy()
        local enemies, arena = getEnemiesInSameArena()
        if #enemies == 0 then return nil end
        local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        local best, dist = nil, math.huge
        for _, e in ipairs(enemies) do
            if isAlive(e) and e.Character and not hasGreenHighlight(e.Character) then
                local eh = e.Character:FindFirstChild("HumanoidRootPart")
                if eh then
                    local d = (eh.Position - hrp.Position).Magnitude
                    if d < dist then dist = d best = e end
                end
            end
        end
        return best
    end

    RunService.RenderStepped:Connect(function()
        if not SCRIPT_ENABLED then 
            targetPlayer = nil
            suspendMovement = false
            return 
        end
        
        if not hasBomb(player.Character) then
            return
        end
        
        if not isAlive(player) then
            resetRound()
            return
        end
        
        if suspendMovement then 
            if tick() > followUntil + 1 then
                suspendMovement = false
                targetPlayer = chooseClosestEnemy()
                if targetPlayer then
                    followUntil = tick() + FOLLOW_DURATION
                end
            end
            return 
        end
        
        if tick() >= followUntil or not targetPlayer or not isAlive(targetPlayer) then
            local newTarget = chooseClosestEnemy()
            if newTarget then
                targetPlayer = newTarget
                followUntil = tick() + FOLLOW_DURATION
            else
                targetPlayer = nil
            end
        end
        
        if lockedByGame then
            targetPlayer = nil
            return
        end

        if targetPlayer and player.Character and targetPlayer.Character then
            local thrp = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
            local myhrp = player.Character:FindFirstChild("HumanoidRootPart")
            local myhum = player.Character:FindFirstChild("Humanoid")
            if thrp and myhrp and myhum then
                local dir = thrp.Position - myhrp.Position
                local dist = dir.Magnitude
                
                if dist > 50 then
                    targetPlayer = chooseClosestEnemy()
                    return
                end
                
                local lookOffset = Vector3.new(math.random(-0.8,0.8),0,math.random(-0.8,0.8))
                myhrp.CFrame = CFrame.new(myhrp.Position, thrp.Position + lookOffset)
                if dist > MIN_DIST then
                    local desired = thrp.Position - (dir.Unit * 0.8)
                    if dist <= STRAFE_DISTANCE then
                        local perp = Vector3.new(-dir.Z,0,dir.X)
                        if perp.Magnitude == 0 then perp = Vector3.new(1,0,0) end
                        perp = perp.Unit
                        local offset = perp * (math.sin(tick() * STRAFE_SPEED) * STRAFE_AMPLITUDE)
                        desired = desired + offset
                    end
                    myhum:MoveTo(desired)
                else
                    myhum:MoveTo(thrp.Position)
                end
            end
        end
    end)

    Tabs.Movement:Toggle({
        Title = "ØªØ´ØºÙŠÙ„ Ø§Ù„Ø£ÙˆØªÙˆ ÙÙˆÙ„Ùˆ",
        Desc = "Ø¨ÙŠØ¸Ù‡Ø± Ø²Ø± Ø§Ù„Ø£ÙˆØªÙˆ Ø¹Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø©",
        Value = false,
        Size = "xlarge",
        Callback = function(state)
            toggleAutoFollow(state)
        end
    })

    Tabs.Movement:Button({
        Title = "Ø§Ø±Ø¬Ø¹ Ø²Ø± Ø§Ù„Ø£ÙˆØªÙˆ Ù„Ù…ÙƒØ§Ù†Ù‡",
        Icon = "refresh-cw",
        Size = "xlarge",
        Callback = function()
            if autoFollowFrame then
                autoFollowPosition = UDim2.new(0, 30, 0, 30)
                autoFollowFrame.Position = autoFollowPosition
            end
        end
    })

    Tabs.Movement:Toggle({
        Title = "ğŸ”’ ØªØ«Ø¨ÙŠØª Ø²Ø± Ø§Ù„Ø£ÙˆØªÙˆ",
        Desc = "ÙŠØ«Ø¨Øª Ø²Ø± Ø§Ù„Ø£ÙˆØªÙˆ ÙÙŠ Ù…ÙƒØ§Ù†Ù‡ Ù„Ù…Ù†Ø¹ ØªØ­Ø±ÙŠÙƒÙ‡",
        Value = false,
        Size = "xlarge",
        Callback = function(state)
            isAutoFollowLocked = state
            
            if autoFollowFrame then
                if state then
                    autoFollowFrame.Draggable = false
                    autoFollowButton.Text = SCRIPT_ENABLED and "Ø§Ù„Ø£ÙˆØªÙˆ: Ø´ØºØ§Ù„ ğŸ”’" or "Ø§Ù„Ø£ÙˆØªÙˆ: Ù…ØªÙˆÙ‚Ù ğŸ”’"
                    WindUI:Notify({
                        Title = "âœ… ØªÙ… ØªØ«Ø¨ÙŠØª Ø²Ø± Ø§Ù„Ø£ÙˆØªÙˆ",
                        Content = "Ù„Ø§ ÙŠÙ…ÙƒÙ† ØªØ­Ø±ÙŠÙƒ Ø²Ø± Ø§Ù„Ø£ÙˆØªÙˆ Ø§Ù„Ø¢Ù†",
                        Duration = 3
                    })
                else
                    autoFollowFrame.Draggable = true
                    autoFollowButton.Text = SCRIPT_ENABLED and "Ø§Ù„Ø£ÙˆØªÙˆ: Ø´ØºØ§Ù„" or "Ø§Ù„Ø£ÙˆØªÙˆ: Ù…ØªÙˆÙ‚Ù"
                    WindUI:Notify({
                        Title = "ğŸ”“ ØªÙ… ÙÙƒ ØªØ«Ø¨ÙŠØª Ø²Ø± Ø§Ù„Ø£ÙˆØªÙˆ",
                        Content = "ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† ØªØ­Ø±ÙŠÙƒ Ø²Ø± Ø§Ù„Ø£ÙˆØªÙˆ",
                        Duration = 3
                    })
                end
            end
        end
    })

    Tabs.Movement:Paragraph({
        Title = "ğŸ“ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ù‡Ù…Ø©",
        Desc = "â€¢ Ù„Ø§ ØªØ´ØºÙ„ Ø§Ù„Ø£ÙˆØªÙˆ ÙˆØ£Ù†Øª Ù…ÙØ¹Ù„ Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø¹Ø§Ù„ÙŠØ© â€¢ Ø§Ù„Ø£ÙˆØªÙˆ ÙŠØ´ØªØºÙ„ ÙÙ‚Ø· Ø¹Ù†Ø¯Ù…Ø§ ØªÙ…Ù„Ùƒ Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© â€¢ Ø¥Ø°Ø§ Ø¹Ù„Ù‚ Ø¬Ø±Ø¨ ØªÙ‚ÙÙ„ ÙˆØªÙØªØ­ Ø§Ù„Ø£ÙˆØªÙˆ Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ© â€¢ Ø¥Ø°Ø§ Ø¶ÙŠØ¹Øª Ø§Ù„Ø²Ø± Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø²Ø±Ø§Ø± \"Ø¥Ø±Ø¬Ø§Ø¹\" ÙˆØ§Ù„Ø²Ø± Ø¨ÙŠØ±Ø¬Ø¹Ù„Ùƒ â€¢ Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± Ø§Ù„ØªØ«Ø¨ÙŠØª Ù„Ù…Ù†Ø¹ ØªØ­Ø±ÙŠÙƒ Ø²Ø± Ø§Ù„Ø£ÙˆØªÙˆ Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø®Ø·Ø£",
        Image = "info",
        ImageSize = 28,
        Color = Color3.fromRGB(255, 165, 0)
    })
end

    -- =============================================
    -- Ù†Ø¸Ø§Ù… Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ù…Ø­Ø¯Ø«Ø©
    -- =============================================
    do
        Tabs.Movement:Paragraph({
            Title = "Speed Settings",
            Desc = "Control your movement speed",
            Image = "zap",
            ImageSize = 28,
            Color = "White"
        })

        local speedActive = false
        local speedConnection = nil
        _G.SpeedValue = _G.SpeedValue or 5

        function _G.SetSpeed(v)
            if type(v) ~= "number" then return end
            _G.SpeedValue = math.clamp(math.floor(v), 1, 100)
        end

        local function valueToSpeed(v)
            local minSpeed, maxSpeed = 16, 35
            local minV, maxV = 1, 10
            local t = (v - minV) / (maxV - minV)
            t = math.clamp(t, 0, 1)
            return minSpeed + (maxSpeed - minSpeed) * t
        end

        local function setupSpeedCharacter(char)
            local humanoid = char:WaitForChild("Humanoid", 5)
            local root = char:WaitForChild("HumanoidRootPart", 5)
            if not humanoid or not root then return end

            if speedConnection then 
                speedConnection:Disconnect() 
                speedConnection = nil
            end

            speedConnection = RunService.RenderStepped:Connect(function()
                if not speedActive or not root or not root.Parent then return end
                
                local moveDir = humanoid.MoveDirection
                if moveDir.Magnitude > 0.01 then
                    local desiredSpeed = valueToSpeed(math.clamp(_G.SpeedValue or 5, 1, 10))
                    if _G.SpeedValue >= 7 then
                        desiredSpeed = desiredSpeed * 1.2
                    elseif _G.SpeedValue >= 5 then
                        desiredSpeed = desiredSpeed * 1.1
                    end
                    local horizDir = Vector3.new(moveDir.X, 0, moveDir.Z)
                    if horizDir.Magnitude > 0 then
                        local newVel = horizDir.Unit * desiredSpeed
                        root.Velocity = Vector3.new(newVel.X, root.Velocity.Y, newVel.Z)
                    end
                else
                    local v = root.Velocity
                    root.Velocity = Vector3.new(v.X * 0.8, v.Y, v.Z * 0.8)
                end
            end)
        end

        local function toggleSpeed(state)
            speedActive = state
            if speedActive then
                if player.Character and not speedConnection then
                    setupSpeedCharacter(player.Character)
                end
            else
                if speedConnection then 
                    speedConnection:Disconnect() 
                    speedConnection = nil
                end
            end
        end

        Tabs.Movement:Input({
            Title = "Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø³Ø±Ø¹Ø© (1-10)",
            Value = tostring(_G.SpeedValue),
            Size = "xlarge",
            Callback = function(value)
                local num = tonumber(value)
                if num then 
                    _G.SetSpeed(num)
                end
            end
        })

        Tabs.Movement:Toggle({
            Title = "ØªØ´ØºÙŠÙ„ Ø§Ù„Ø³Ø±Ø¹Ø© ",
            Desc =" Ø§Ù„Ø³Ø±Ø¹Ø© Ø§Ù„Ø®Ø¨ÙŠØ«Ù‡ Ù…Ù† 1 Ø§Ù„ÙŠ 5 Ùˆ Ø§Ù„Ø³Ø±ÙŠØ¹Ø© Ù…Ù† 6 Ø§Ù„ÙŠ 10",
            Value = false,
            Size = "xlarge",
            Callback = function(state) 
                toggleSpeed(state)
            end
        })

        Tabs.Movement:Toggle({
    Title = "Ù…Ù†Ø¹ Ø§Ù„Ø§Ù†Ø²Ù„Ø§Ù‚ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù„ÙŠØ¯",
    Desc = "",
    Value = false,
    Size = "xlarge",
    Callback = function(state) 
        if state then
            --// Exact Ice Part Modifier (By Name + Position)
            local TARGET_NAME = "Ice"

            -- Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ù„ÙŠ Ø£Ø±Ø³Ù„ØªÙ‡ (Ù†Ø³ØªØ®Ø¯Ù… ØªÙ‚Ø±ÙŠØ¨ Ù…Ùˆ ØªØ·Ø§Ø¨Ù‚ Ø­Ø±ÙÙŠ)
            local TARGET_POSITION = Vector3.new(
                42.99999237060547,
                0.5,
                -29.999984741210938
            )

            -- Ù†Ø³Ø¨Ø© Ø§Ù„Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ÙØ±Ù‚ (Ø¹Ø´Ø§Ù† Ø§Ù„ÙƒØ³ÙˆØ±)
            local POSITION_TOLERANCE = 0.1

            local function isSamePosition(pos1, pos2)
                return (pos1 - pos2).Magnitude <= POSITION_TOLERANCE
            end

            for _, v in ipairs(workspace:GetDescendants()) do
                if v:IsA("BasePart")
                    and v.Name == TARGET_NAME
                    and v.Material == Enum.Material.Ice
                    and isSamePosition(v.Position, TARGET_POSITION)
                then
                    -- ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠØ© (Ù…Ù†Ø¹ Ø§Ù„ØªØ²Ø­Ù„Ù‚)
                    v.CustomPhysicalProperties = PhysicalProperties.new(
                        1,   -- Density
                        6,   -- Friction (Ø§Ø±ÙØ¹Ù‡ Ù„Ùˆ Ù„Ø³Ø§ ÙŠØ²Ø­Ù„Ù‚)
                        0,   -- Elasticity
                        6,
                        0
                    )

                    
                    
                    -- Ø¥Ø¶Ø§ÙØ© Ø¥Ø´Ø¹Ø§Ø± ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø©
                    WindUI:Notify({
                        Title = "âœ… ØªÙ… Ù…Ù†Ø¹ Ø§Ù„Ø§Ù†Ø²Ù„Ø§Ù‚ Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù„ÙŠØ¯",
                        Content = "ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø¬Ù„ÙŠØ¯ Ø¨Ù†Ø¬Ø§Ø­",
                        Duration = 3
                    })
                end
            end
            
            -- Ø¥Ø¶Ø§ÙØ© ØªØ­Ø¯ÙŠØ« Ø¯ÙˆØ±ÙŠ Ù„Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¨Ù‚Ø§Ø¡ Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
            local iceModifierConnection = RunService.Heartbeat:Connect(function()
                if not state then
                    iceModifierConnection:Disconnect()
                    return
                end
                
                for _, v in ipairs(workspace:GetDescendants()) do
                    if v:IsA("BasePart")
                        and v.Name == TARGET_NAME
                        and v.Material == Enum.Material.Ice
                        and isSamePosition(v.Position, TARGET_POSITION)
                    then
                        -- Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø§Ù„ØªØ¹Ø¯ÙŠÙ„
                        if not v.CustomPhysicalProperties or 
                           v.CustomPhysicalProperties.Friction < 5 then
                            v.CustomPhysicalProperties = PhysicalProperties.new(1, 6, 0, 6, 0)
                        end
                    end
                end
            end)
            
            -- ØªØ®Ø²ÙŠÙ† Ø§Ù„Ø§ØªØµØ§Ù„ Ù„Ù‚Ø·Ø¹Ù‡ Ø¹Ù†Ø¯ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù†Ø¸Ø§Ù…
            _G.IceModifierConnection = iceModifierConnection
            
        else
            -- Ø¹Ù†Ø¯ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù†Ø¸Ø§Ù…
            if _G.IceModifierConnection then
                _G.IceModifierConnection:Disconnect()
                _G.IceModifierConnection = nil
            end
            
            -- Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„ÙŠØ¯ Ù„Ø­Ø§Ù„ØªÙ‡ Ø§Ù„Ø·Ø¨ÙŠØ¹ÙŠØ© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ)
            for _, v in ipairs(workspace:GetDescendants()) do
                if v:IsA("BasePart")
                    and v.Name == TARGET_NAME
                    and v.Material == Enum.Material.Ice
                then
                    v.CustomPhysicalProperties = nil  -- Ø¥Ø±Ø¬Ø§Ø¹ Ù„Ù„Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
                end
            end
            
            WindUI:Notify({
                Title = "âŒ ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ù…Ù†Ø¹ Ø§Ù„Ø§Ù†Ø²Ù„Ø§Ù‚",
                Content = "Ø§Ù„Ø¬Ù„ÙŠØ¯ Ø±Ø¬Ø¹ ÙƒÙ…Ø§ ÙƒØ§Ù†",
                Duration = 3
            })
        end
    end
})

        player.CharacterAdded:Connect(function(char)
            task.wait(1)
            if speedActive then
                setupSpeedCharacter(char)
            end
        end)

        if player.Character then 
            task.wait(1)
            if speedActive then
                setupSpeedCharacter(player.Character) 
            end
        end
    end

    -- =============================================
    -- Ù†Ø¸Ø§Ù… Ø§Ù„Ø·ÙŠØ±Ø§Ù†
    -- =============================================
    do
        Tabs.Movement:Paragraph({
            Title = "Flight Features",
            Desc = "Control advanced flight",
            Image = "feather",
            ImageSize = 28,
            Color = "White"
        })

        local CFloop = nil
        local CFspeed = 50
        local flyActive = false

        local function toggleAdvancedFly()
            if CFloop then 
                CFloop:Disconnect()
                CFloop = nil
                local speaker = game.Players.LocalPlayer
                if speaker.Character then
                    local humanoid = speaker.Character:FindFirstChildOfClass('Humanoid')
                    if humanoid then humanoid.PlatformStand = false end
                    local head = speaker.Character:FindFirstChild("Head")
                    if head then head.Anchored = false end
                end
                flyActive = false
            else
                local speaker = game.Players.LocalPlayer
                local character = speaker.Character
                if not character then return end
                
                local humanoid = character:FindFirstChildOfClass('Humanoid')
                if not humanoid then return end
                
                humanoid.PlatformStand = true
                local head = character:WaitForChild("Head")
                head.Anchored = true
                
                CFloop = game:GetService("RunService").Heartbeat:Connect(function(deltaTime)
                    if not character or not head then return end
                    
                    local moveDirection = humanoid.MoveDirection * (CFspeed * deltaTime)
                    local headCFrame = head.CFrame
                    local cameraCFrame = workspace.CurrentCamera.CFrame
                    local cameraOffset = headCFrame:ToObjectSpace(cameraCFrame).Position
                    cameraCFrame = cameraCFrame * CFrame.new(-cameraOffset.X, -cameraOffset.Y, -cameraOffset.Z + 1)
                    local cameraPosition = cameraCFrame.Position
                    local headPosition = headCFrame.Position

                    local objectSpaceVelocity = CFrame.new(cameraPosition, Vector3.new(headPosition.X, cameraPosition.Y, headPosition.Z)):VectorToObjectSpace(moveDirection)
                    head.CFrame = CFrame.new(headPosition) * (cameraCFrame - cameraPosition) * CFrame.new(objectSpaceVelocity)
                end)
                
                flyActive = true
            end
        end

        Tabs.Movement:Toggle({
            Title = "Ø·ÙŠØ±Ø§Ù† ",
            Desc = "Ø¨ØªØ·ÙŠØ± Ùˆ Ø¨ÙŠØ¸Ù‡Ø± Ù„ÙƒÙ„ Ø§Ø°Ø§ ÙÙŠ Ù‚ÙŠÙ…",
            Value = false,
            Size = "xlarge",
            Callback = function(state)
                if state then 
                    toggleAdvancedFly() 
                else 
                    if CFloop then 
                        toggleAdvancedFly() 
                    end 
                end
            end
        })

        Tabs.Movement:Input({
            Title = "(200-50) Ø§Ù„Ø·ÙŠØ±Ø§Ù†",
            Value = "50",
            Size = "xlarge",
            Callback = function(value)
                local num = tonumber(value)
                if num and num > 0 and num <= 200 then 
                    CFspeed = num
                end
            end
        })

        Tabs.Movement:Button({
            Title = "ÙˆÙ‚Ù Ø§Ù„Ø·ÙŠØ±Ø§Ù†",
            Icon = "square",
            Size = "xlarge", 
            Callback = function()
                if CFloop then 
                    toggleAdvancedFly()
                end
            end
        })
    end

-- =============================================
-- Ù†Ø¸Ø§Ù… Ø§Ù„Ø¯Ø¨Ù„ Ù†Ø· - ÙŠÙØ¶Ù„ Ø´ØºØ§Ù„ Ø¨Ø¹Ø¯ Ø§Ù„Ù…ÙˆØª
-- =============================================
do
    local doubleJumpActive = false
    local jumpConnection = nil
    
    Tabs.Movement:Toggle({
        Title = "Ø¯Ø¨Ù„ Ù†Ø·",
        Desc = "Ù†Ø· Ù…Ø±ØªÙŠÙ† ÙÙŠ Ù‡ÙˆØ§Ø¡ ØªØ³ØªØ®Ø¯Ù… ÙÙŠ Ù…Ø§Ø¨ Ù†Ø·",
        Value = false,
        Size = "xlarge",
        Callback = function(state)
            doubleJumpActive = state
            
            if state then
                -- Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„ØªÙØ¹ÙŠÙ„
                WindUI:Notify({
                    Title = "âœ… Ø¯Ø¨Ù„ Ù†Ø· Ù…ÙØ¹Ù„",
                    Content = "Ø§Ù†Ø· Ù…Ø±ØªÙŠÙ† ÙÙŠ Ø§Ù„Ù‡ÙˆØ§Ø¡",
                    Duration = 3
                })
                
                -- ØªØ´ØºÙŠÙ„ Ø§Ù„Ù†Ø¸Ø§Ù…
                local player = Players.LocalPlayer
                
                -- ÙˆØ¸ÙŠÙØ© Ø¥Ù†Ø´Ø§Ø¡ Ø§ØªØµØ§Ù„ Ø¬Ø¯ÙŠØ¯
                local function createJumpConnection()
                    if jumpConnection then
                        jumpConnection:Disconnect()
                    end
                    
                    jumpConnection = UserInputService.JumpRequest:Connect(function()
                        if not doubleJumpActive then return end
                        
                        local character = player.Character
                        if not character then return end
                        
                        local humanoid = character:FindFirstChild("Humanoid")
                        local rootPart = character:FindFirstChild("HumanoidRootPart")
                        
                        if not humanoid or not rootPart then return end
                        if humanoid.Health <= 0 then return end
                        
                        -- Ø¥Ø°Ø§ Ø§Ù„Ø´Ø®ØµÙŠØ© ÙÙŠ Ø§Ù„Ù‡ÙˆØ§Ø¡
                        local state = humanoid:GetState()
                        if state == Enum.HumanoidStateType.Freefall or 
                           state == Enum.HumanoidStateType.Jumping then
                            
                            -- Ø§Ù„Ù‚ÙØ²Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©
                            rootPart.Velocity = Vector3.new(
                                rootPart.Velocity.X,
                                50,  -- Ù‚ÙˆØ© Ø§Ù„Ù‚ÙØ²Ø©
                                rootPart.Velocity.Z
                            )
                        end
                    end)
                end
                
                -- Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ø£ÙˆÙ„
                createJumpConnection()
                
                -- Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø´Ø®ØµÙŠØ§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© (Ø¨Ø¹Ø¯ Ø§Ù„Ù…ÙˆØª)
                player.CharacterAdded:Connect(function()
                    task.wait(0.5)  -- Ø§Ø³ØªÙ†Ù‰ Ø´ÙˆÙŠ Ø¹Ø´Ø§Ù† Ø§Ù„Ø´Ø®ØµÙŠØ© ØªØªØ­Ù…Ù„
                    if doubleJumpActive then
                        createJumpConnection()  -- Ø£Ø¹ÙŠØ¯ ØµÙ†Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„
                    end
                end)
                
                -- Ù…ØªØ§Ø¨Ø¹Ø© Ø¥Ø°Ø§ Ø§Ù„Ø´Ø®ØµÙŠØ© Ø±Ø¬Ø¹Øª
                player.CharacterRemoving:Connect(function()
                    -- Ù†Ø¸Ù Ø§Ù„Ø§ØªØµØ§Ù„ Ø§Ù„Ù‚Ø¯ÙŠÙ… Ø¹Ø´Ø§Ù† Ù…Ø§ ÙŠØªØ¯Ø§Ø®Ù„
                    if jumpConnection then
                        jumpConnection:Disconnect()
                        jumpConnection = nil
                    end
                end)
                
            else
                -- Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù†Ø¸Ø§Ù…
                if jumpConnection then
                    jumpConnection:Disconnect()
                    jumpConnection = nil
                end
                
                -- Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù
                WindUI:Notify({
                    Title = "âŒ Ø¯Ø¨Ù„ Ù†Ø· Ù…ÙˆÙ‚Ù",
                    Content = "Ø§Ù„Ù‚ÙØ²Ø© Ø±Ø¬Ø¹Øª Ø¹Ø§Ø¯ÙŠØ©",
                    Duration = 3
                })
            end
        end
    })
    
    -- ØªÙ†Ø¸ÙŠÙ Ø¹Ù†Ø¯ Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ø³ÙƒØ±Ø¨Øª
    Window:OnDestroy(function()
        if jumpConnection then
            jumpConnection:Disconnect()
        end
    end)
end

    -- =============================================
    -- ØªØ¨ÙˆÙŠØ¨ Ø§Ù„Ø±Ø¤ÙŠØ©
    -- =============================================
    do
        Tabs.Visuals:Paragraph({
            Title = "Visual Settings",
            Desc = "Enhance your vision and game performance",
            Image = "eye",
            ImageSize = 28,
            Color = "White"
        })

        Tabs.Visuals:Toggle({
            Title = "ØªØ´ØºÙŠÙ„ Ø§Ø¶Ø§Ø¡Ø©",
            Desc = "Ø¨ÙŠØ®Ù„ÙŠ ÙƒÙ„ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ù…Ø¶ÙŠØ©",
            Value = false,
            Size = "xlarge",
            Callback = function(state)
                if state then
                    Lighting.Brightness = 2
                    Lighting.ClockTime = 14
                    Lighting.FogEnd = 100000
                    Lighting.GlobalShadows = false
                else
                    Lighting.Brightness = 1
                    Lighting.ClockTime = 14
                    Lighting.FogEnd = 10000
                    Lighting.GlobalShadows = true
                end
            end
        })

        local fpsBoostActive = false

        local function ApplyFPSBooster(state)
            fpsBoostActive = state
            if fpsBoostActive then
                local Terrain = workspace:FindFirstChildOfClass('Terrain')
                if Terrain then
                    Terrain.WaterWaveSize = 0
                    Terrain.WaterWaveSpeed = 0
                    Terrain.WaterReflectance = 0
                    Terrain.WaterTransparency = 0
                end

                Lighting.GlobalShadows = false
                Lighting.FogEnd = 9e9

                pcall(function() settings().Rendering.QualityLevel = Enum.QualityLevel.Level01 end)

                for _, v in pairs(game:GetDescendants()) do
                    if v:IsA("Part") or v:IsA("MeshPart") or v:IsA("UnionOperation") then
                        v.Material = Enum.Material.Plastic
                        v.Reflectance = 0
                    elseif v:IsA("Decal") then v.Transparency = 1
                    elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then v.Lifetime = NumberRange.new(0) end
                end

                for _, v in pairs(Lighting:GetDescendants()) do
                    if v:IsA("BlurEffect") or v:IsA("SunRaysEffect") or v:IsA("BloomEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("DepthOfFieldEffect") then
                        v.Enabled = false
                    end
                end
            else
                Lighting.GlobalShadows = true
                Lighting.FogEnd = 100000
                settings().Rendering.QualityLevel = Enum.QualityLevel.Automatic
            end
        end

        Tabs.Visuals:Toggle({
            Title = "Anti Lag: ØªØ³Ø±ÙŠØ¹ Ø§Ù„Ù„Ø¹Ø¨Ø©",
            Desc = "Ø¨ÙŠØ­Ø³Ù† Ø£Ø¯Ø§Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© ÙˆÙŠØ²ÙŠØ¯ Ø§Ù„Ø³Ø±Ø¹Ø© Ø¨Ø´ÙƒÙ„ ÙƒØ¨ÙŠØ±",
            Value = false,
            Size = "xlarge",
            Callback = function(state) 
                ApplyFPSBooster(state)
            end
        })
    end

    -- =============================================
    -- ØªØ¨ÙˆÙŠØ¨ Other
    -- =============================================
    do
        Tabs.Other:Paragraph({
            Title = "Other Scripts",
            Desc = "Additional scripts and features",
            Image = "box",
            ImageSize = 28,
            Color = "White"
        })

        Tabs.Other:Button({
            Title = " ğŸ¤Ù‡ÙŠØ¯Ù„ÙŠØ³ & ÙƒÙˆØ±Ø¨Ù„ÙˆÙƒØ³",
            Desc = "Ù…Ù„Ø§Ø­Ø¸Ø©: ØªØ±Ø§ ÙŠØ¨Ø§Ù† Ù„Ùƒ Ø¨Ø³",
            Icon = "user",
            Size = "xlarge",
            Callback = function()
                loadstring(game:HttpGet("https://pastebin.com/raw/hwPZXtfq"))()
            end
        })

        Tabs.Other:Button({
            Title = "Ø³ÙƒØ±Ø¨Øª Ø±Ù‚ØµØ§ØªğŸ”¥",
            Desc = "Ø±Ù‚ØµØ§Øª ØªØ¸Ù‡Ø± Ù„Ù†Ø§Ø³",
            Icon = "activity",
            Size = "xlarge",
            Callback = function()
                loadstring(game:HttpGet("https://raw.githubusercontent.com/Client-dotcom/Admins/main/Dance.txt"))()
            end
        })
    end

-- =============================================
-- ØªØ¨ÙˆÙŠØ¨ Ø¨Ø±Ùˆ X ÙÙŠØªØ´Ø±Ø² (Ù†Ø¸Ø§Ù… Tebnid Ø§Ù„ÙƒØ§Ù…Ù„)
-- =============================================
do
    Tabs.ProXFeatures:Paragraph({
        Title = "ProXfeatures ",
        Desc = "",
        Image = "zap",
        ImageSize = 28,
        Color = Color3.fromRGB(255, 165, 0)
    })

    -- ========== Ù…ØªØºÙŠØ±Ø§Øª Ù†Ø¸Ø§Ù… Tebnid ==========
    local EnemyDetection = false
    local SmartEvasion = false
    local AutoLavaCopy = false
    
    local bombLoop = nil
    local originalPosition = nil
    local isUsingBomb = false
    
    local evasionConnection = nil
    local spinConnection = nil
    
    local copiedLavaObjects = {}
    local lavaDataCache = {}

    -- ========== Ø¯ÙˆØ§Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ==========
    local function isInGame()
        local playerGui = player:FindFirstChild("PlayerGui")
        if playerGui and playerGui:FindFirstChild("TBDUI") and playerGui.TBDUI:FindFirstChild("Main") and playerGui.TBDUI.Main:FindFirstChild("Scorebar") then
            return playerGui.TBDUI.Main.Scorebar.Visible
        end
        return false
    end

    local function detectEnemyPlayers()
        local enemyPlayers = {}
        local localPlayerTeam = nil
        local currentArenaForLocalPlayer = nil 
        
        if workspace.Arenas then
            for arenaName, arena in pairs(workspace.Arenas:GetChildren()) do
                if arena:FindFirstChild("Slots") then
                    if arena.Slots:FindFirstChild("Left") then
                        for i = 1, 4 do
                            local slot = arena.Slots.Left:FindFirstChild(tostring(i))
                            if slot and slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") then
                                local slotPlayer = slot.Data.Player.Value
                                if slotPlayer == player then
                                    localPlayerTeam = "Left"
                                    currentArenaForLocalPlayer = arena 
                                    break
                                end
                            end
                        end
                    end
                    
                    if not currentArenaForLocalPlayer and arena.Slots:FindFirstChild("Right") then
                        for i = 1, 4 do
                            local slot = arena.Slots.Right:FindFirstChild(tostring(i))
                            if slot and slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") then
                                local slotPlayer = slot.Data.Player.Value
                                if slotPlayer == player then
                                    localPlayerTeam = "Right"
                                    currentArenaForLocalPlayer = arena
                                    break
                                end
                            end
                        end
                    end
                    
                    if localPlayerTeam and currentArenaForLocalPlayer then 
                        local enemyTeam = (localPlayerTeam == "Left") and "Right" or "Left"
                        
                        if currentArenaForLocalPlayer.Slots:FindFirstChild(enemyTeam) then
                            for i = 1, 4 do
                                local slot = currentArenaForLocalPlayer.Slots[enemyTeam]:FindFirstChild(tostring(i))
                                if slot and slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") then
                                    local enemyPlayer = slot.Data.Player.Value
                                    if enemyPlayer and enemyPlayer ~= player then
                                        table.insert(enemyPlayers, enemyPlayer)
                                    end
                                end
                            end
                        end
                        break 
                    end
                end
            end
        end
        
        return enemyPlayers, currentArenaForLocalPlayer 
    end

    local function isPlayerOnArenaFloor(plr, arena)
        if not plr or not arena then return false end
        
        if arena:FindFirstChild("Slots") then
            for _, side in pairs({"Left", "Right"}) do
                if arena.Slots:FindFirstChild(side) then
                    for i = 1, 4 do
                        local slot = arena.Slots[side]:FindFirstChild(tostring(i))
                        if slot and slot:FindFirstChild("Data") and slot.Data:FindFirstChild("Player") then
                            local slotPlayer = slot.Data.Player.Value
                            
                            if slotPlayer == plr then
                                if slot:FindFirstChild("Pad") then
                                    local pad = slot.Pad
                                    local color = pad.Color
                                    
                                    if math.abs(color.R - 255/255) < 0.01 and 
                                       math.abs(color.G - 89/255) < 0.01 and 
                                       math.abs(color.B - 89/255) < 0.01 then
                                        return false 
                                    else
                                        return true 
                                    end
                                end
                                return true
                            end
                        end
                    end
                end
            end
        end
        return false
    end

    local function isPlayerAlive(plr)
        if plr and plr.Character and plr.Character:FindFirstChild("Humanoid") then
            local humanoid = plr.Character.Humanoid
            if humanoid.Health > 0 then return true end
        end
        return false
    end

    local function findBombTool()
        local localCharacter = player.Character
        if localCharacter then
            local bombTool = localCharacter:FindFirstChild("Bomb")
            if bombTool then return bombTool, localCharacter end
            
            if localCharacter:FindFirstChild("Humanoid") then
                for _, tool in pairs(localCharacter:GetChildren()) do
                    if tool:IsA("Tool") and tool.Name == "Bomb" then
                        return tool, localCharacter
                    end
                end
            end
        end
        
        if workspace.Characters then
            local specificCharacter = workspace.Characters:FindFirstChild(player.Name)
            if specificCharacter then
                local bombTool = specificCharacter:FindFirstChild("Bomb")
                if bombTool then return bombTool, specificCharacter end
            end
        end
        
        return nil, nil
    end

    local function hasEnemyBomb(enemy)
        if enemy.Character then
            local bombTool = enemy.Character:FindFirstChild("Bomb")
            if bombTool then return true end
            
            for _, tool in pairs(enemy.Character:GetChildren()) do
                if tool:IsA("Tool") and tool.Name == "Bomb" then
                    return true
                end
            end
        end
        return false
    end

    local function getEnemiesWithBombs(enemies)
        local enemiesWithBombs = {}
        for _, enemy in pairs(enemies) do
            if hasEnemyBomb(enemy) then
                table.insert(enemiesWithBombs, enemy)
            end
        end
        return enemiesWithBombs
    end

    local function checkPathClear(startPos, endPos)
        local direction = (endPos - startPos)
        local distance = direction.Magnitude
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {player.Character}
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        
        local result = workspace:Raycast(startPos, direction, raycastParams)
        
        if result then
            return false, result.Position
        else
            return true, nil
        end
    end

    local function isPositionInArena(pos, arena)
        if arena and arena:IsA("Part") then
            local bounds = arena.CFrame:pointToObjectSpace(pos)
            local halfSize = arena.Size / 2
            return math.abs(bounds.X) <= halfSize.X and math.abs(bounds.Y) <= halfSize.Y and math.abs(bounds.Z) <= halfSize.Z
        end
        return true 
    end

    local function findUltimateEscapePosition(currentPosition, primaryEnemy, allEnemies, arena)
        local character = player.Character
        if not character or not character:FindFirstChild("HumanoidRootPart") then
            return currentPosition
        end

        local primaryEnemyPos = primaryEnemy.Character.HumanoidRootPart.Position
        local primaryDistance = (currentPosition - primaryEnemyPos).Magnitude

        if primaryDistance < 8 then
            local emergencyDirection = (currentPosition - primaryEnemyPos).Unit

            for testDist = 15, 5, -2 do
                local emergencyPos = currentPosition + (emergencyDirection * testDist)
                emergencyPos = Vector3.new(emergencyPos.X, currentPosition.Y, emergencyPos.Z)

                local pathClear, actualPos = checkPathClear(currentPosition, emergencyPos)

                if pathClear and isPositionInArena(emergencyPos, arena) then
                    return emergencyPos
                elseif actualPos then
                    local safePos = currentPosition + (emergencyDirection * ((actualPos - currentPosition).Magnitude - 1))
                    safePos = Vector3.new(safePos.X, currentPosition.Y, safePos.Z)
                    if isPositionInArena(safePos, arena) then
                        return safePos
                    end
                end
            end
        end

        local bestPosition = currentPosition
        local maxSafetyScore = 0

        local directions = {}
        for angle = 0, 315, 30 do
            local rad = math.rad(angle)
            table.insert(directions, Vector3.new(math.cos(rad), 0, math.sin(rad)))
        end

        for _, direction in pairs(directions) do
            for testDistance = 6, 25, 3 do
                local testPosition = currentPosition + (direction * testDistance)
                testPosition = Vector3.new(testPosition.X, currentPosition.Y, testPosition.Z)

                local pathClear, blockedAt = checkPathClear(currentPosition, testPosition)

                if not pathClear then
                    if blockedAt then
                        local safeDistance = (blockedAt - currentPosition).Magnitude
                        if safeDistance > 3 then
                            testPosition = currentPosition + (direction * (safeDistance - 2))
                            testPosition = Vector3.new(testPosition.X, currentPosition.Y, testPosition.Z)
                            testDistance = safeDistance - 2
                        else
                            break
                        end
                    else
                        break
                    end
                end

                if not isPositionInArena(testPosition, arena) then
                    break
                end

                local safetyScore = 0
                local minEnemyDistance = math.huge

                for _, enemy in pairs(allEnemies) do
                    if enemy.Character and enemy.Character:FindFirstChild("HumanoidRootPart") then
                        local enemyPos = enemy.Character.HumanoidRootPart.Position
                        local distanceToEnemy = (testPosition - enemyPos).Magnitude

                        minEnemyDistance = math.min(minEnemyDistance, distanceToEnemy)

                        if enemy == primaryEnemy then
                            safetyScore = safetyScore + (distanceToEnemy * 3)
                        else
                            safetyScore = safetyScore + (distanceToEnemy * 1.5)
                        end
                    end
                end

                if minEnemyDistance > 12 and minEnemyDistance < 30 then
                    safetyScore = safetyScore + 25
                end

                if pathClear then
                    safetyScore = safetyScore + 15
                end

                if testDistance > 8 and testDistance < 20 then
                    safetyScore = safetyScore + 10
                end

                if safetyScore > maxSafetyScore then
                    maxSafetyScore = safetyScore
                    bestPosition = testPosition
                end
            end
        end

        local finalCheck, blockedAt = checkPathClear(currentPosition, bestPosition)
        if not finalCheck then
            if blockedAt then
                local fallbackDirection = (bestPosition - currentPosition).Unit
                for dist = 5, 15, 2 do
                    local fallbackPos = currentPosition + (fallbackDirection * dist)
                    fallbackPos = Vector3.new(fallbackPos.X, currentPosition.Y, fallbackPos.Z)
                    local fallbackCheck, _ = checkPathClear(currentPosition, fallbackPos)
                    if fallbackCheck and isPositionInArena(fallbackPos, arena) then
                        return fallbackPos
                    end
                end
            end
            return currentPosition
        end

        return bestPosition
    end

    local function useBombOnEnemy(bombTool, character, targetEnemy)
        if bombLoop or not bombTool or not character or not targetEnemy or not targetEnemy.Character then
            return false
        end

        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        local targetRootPart = targetEnemy.Character:FindFirstChild("HumanoidRootPart")
        if not humanoidRootPart or not targetRootPart then
            return false
        end

        if not isUsingBomb then
            originalPosition = humanoidRootPart.CFrame
            isUsingBomb = true
        end

        local lastTargetCFrame = targetRootPart.CFrame
        local cframeChangeHistory = {}
        local maxHistorySize = 3

        local thresholds = {
            {limit = 0.5,  offset = 0},
            {limit = 1.0,  offset = -7},
            {limit = 1.5,  offset = -14},
            {limit = 2.0,  offset = -21},
            {limit = 3.0,  offset = -27},
            {limit = 4.0,  offset = -36},
            {limit = math.huge, offset = -43}
        }

        bombLoop = task.spawn(function()
            local bombActivated = false
            local attempts = 0
            local maxAttempts = 100

            while EnemyDetection and character:FindFirstChild("Bomb") and attempts < maxAttempts do
                attempts += 1
                task.wait(0.001)
                if not targetRootPart or not humanoidRootPart then break end

                local currentCFrame = targetRootPart.CFrame
                local cframeChange = (currentCFrame.Position - lastTargetCFrame.Position).Magnitude

                table.insert(cframeChangeHistory, cframeChange)
                if #cframeChangeHistory > maxHistorySize then
                    table.remove(cframeChangeHistory, 1)
                end

                local avgChange = 0
                for _, change in ipairs(cframeChangeHistory) do
                    avgChange += change
                end
                avgChange = avgChange / #cframeChangeHistory

                local baseOffset = 0
                for _, t in ipairs(thresholds) do
                    if avgChange <= t.limit then
                        baseOffset = t.offset
                        break
                    end
                end

                local enemyVelocity = targetRootPart.Velocity
                local predictionTime = 0.05
                local predictedPosition = targetRootPart.Position + (enemyVelocity * predictionTime)

                local predictedCFrame = CFrame.new(predictedPosition, predictedPosition + targetRootPart.CFrame.LookVector)
                local smartBehindPosition = predictedCFrame * CFrame.new(0, 0, baseOffset)

                local raycastParams = RaycastParams.new()
                raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
                raycastParams.FilterDescendantsInstances = {character, targetEnemy.Character}
                local direction = (smartBehindPosition.Position - humanoidRootPart.Position)
                local raycastResult = workspace:Raycast(humanoidRootPart.Position, direction.Unit * direction.Magnitude, raycastParams)

                if raycastResult then
                    smartBehindPosition = CFrame.new(raycastResult.Position) * CFrame.new(0,0,-1)
                end

                humanoidRootPart.CFrame = smartBehindPosition
                lastTargetCFrame = currentCFrame

                if not bombActivated then
                    bombActivated = true
                    task.wait(0.02)
                end
            end

            bombLoop = nil
            isUsingBomb = false
            if originalPosition and humanoidRootPart then
                humanoidRootPart.CFrame = originalPosition
            end
            originalPosition = nil
        end)

        return true
    end

    local function startEnemyDetectionLoop()
        spawn(function()
            while EnemyDetection do
                task.wait(.0015)
                
                if not isInGame() then
                    task.wait(0.2)
                    continue
                end
                
                local enemies, arenaOfLocalPlayer = detectEnemyPlayers()
                
                local validEnemies = {}
                if arenaOfLocalPlayer then
                    for _, enemy in pairs(enemies) do
                        if isPlayerAlive(enemy) and isPlayerOnArenaFloor(enemy, arenaOfLocalPlayer) then
                            table.insert(validEnemies, enemy)
                        end
                    end
                end

                if #validEnemies > 0 and not isUsingBomb then
                    local firstValidEnemy = validEnemies[1]
                    local bombTool, character = findBombTool()
                    
                    if bombTool and character then
                        useBombOnEnemy(bombTool, character, firstValidEnemy)
                    end
                elseif #validEnemies == 0 then
                    if isUsingBomb and originalPosition then
                        local character = player.Character
                        if character and character:FindFirstChild("HumanoidRootPart") then
                            originalPosition = nil
                            isUsingBomb = false
                            if bombLoop then
                                bombLoop = nil
                            end
                        end
                    end
                end
            end
        end)
    end

    local function goToUpAndSpin()
        spawn(function()
            local targetCenter = Vector3.new(116.876785, 47, 34.0727844)
            local circleRadius = 30
            local circleSpeed = 0.1
            local currentAngle = 0
            local isAtTarget = false
            local emergencyMode = false
            
            local function touchingLavaCopy(character)
                if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
                local hrp = character.HumanoidRootPart
                local touchingParts = hrp:GetTouchingParts()
                for _, part in ipairs(touchingParts) do
                    if part.Name:sub(1, 8) == "LavaCopy" then
                        return true
                    end
                end
                return false
            end

            local function moveToTargetHeight()
                local character = player.Character
                if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
                
                local root = character.HumanoidRootPart
                local currentPos = root.Position
                
                if math.abs(currentPos.Y - targetCenter.Y) < 2 then
                    isAtTarget = true
                    return true
                end
                
                root.CFrame = CFrame.new(targetCenter)
                isAtTarget = true
                
                return true
            end

            local function performCircularMovement()
                local character = player.Character
                if not character or not character:FindFirstChild("HumanoidRootPart") then return end
                
                local root = character.HumanoidRootPart
                currentAngle = currentAngle + circleSpeed
                
                local x = targetCenter.X + math.cos(currentAngle) * circleRadius
                local z = targetCenter.Z + math.sin(currentAngle) * circleRadius
                local circlePos = Vector3.new(x, targetCenter.Y, z)
                
                root.CFrame = CFrame.new(circlePos)
            end

            while SmartEvasion do
                task.wait(0.01)

                if not isInGame() then
                    task.wait(0.2)
                    continue
                end

                local character = player.Character
                if not character or not character:FindFirstChild("HumanoidRootPart") then
                    task.wait()
                    continue
                end

                local humanoidRootPart = character.HumanoidRootPart
                local currentPosition = humanoidRootPart.Position

                if touchingLavaCopy(character) then
                    emergencyMode = true
                    humanoidRootPart.CFrame = humanoidRootPart.CFrame + Vector3.new(0, 60, 0)
                    task.wait(0.1)
                    continue
                end

                local enemies, currentArena = detectEnemyPlayers()
                local enemiesWithBombs = getEnemiesWithBombs(enemies)

                if #enemiesWithBombs > 0 and not isUsingBomb then
                    emergencyMode = false
                    
                    if not isAtTarget then
                        moveToTargetHeight()
                    else
                        performCircularMovement()
                    end
                else
                    emergencyMode = false
                end
            end
        end)
    end

    local function handlePlayerEvasion()
        spawn(function()
            local lastEvasionTime = 0
            local emergencyMode = false
            local lastKnownEnemyPositions = {}
            local lastSafePos = nil
            local stuckCheckTime = tick()

            local function touchingLavaCopy(character)
                if not character or not character:FindFirstChild("HumanoidRootPart") then return false end
                local hrp = character.HumanoidRootPart
                local touchingParts = hrp:GetTouchingParts()
                for _, part in ipairs(touchingParts) do
                    if part.Name:sub(1, 8) == "LavaCopy" then
                        return true
                    end
                end
                return false
            end

            while SmartEvasion do
                task.wait()

                if not isInGame() then
                    task.wait(0.2)
                    continue
                end

                local character = player.Character
                if not character or not character:FindFirstChild("HumanoidRootPart") then
                    task.wait()
                    continue
                end

                local humanoidRootPart = character.HumanoidRootPart
                local currentPosition = humanoidRootPart.Position
                local currentTime = tick()

                if touchingLavaCopy(character) then
                    emergencyMode = true
                    humanoidRootPart.CFrame = humanoidRootPart.CFrame + Vector3.new(0, 20, 0)
                    task.wait(0.2)
                    continue
                end

                local enemies, currentArena = detectEnemyPlayers()
                local enemiesWithBombs = getEnemiesWithBombs(enemies)

                if #enemiesWithBombs > 0 and not isUsingBomb then
                    local mostDangerousEnemy = nil
                    local closestDistance = math.huge
                    local highestThreat = 0

                    for _, enemy in pairs(enemiesWithBombs) do
                        if enemy.Character and enemy.Character:FindFirstChild("HumanoidRootPart") then
                            local enemyPos = enemy.Character.HumanoidRootPart.Position
                            local distance = (currentPosition - enemyPos).Magnitude

                            local enemyVelocity = Vector3.new(0, 0, 0)
                            if lastKnownEnemyPositions[enemy.UserId] then
                                local lastPos = lastKnownEnemyPositions[enemy.UserId].position
                                local timeDiff = currentTime - lastKnownEnemyPositions[enemy.UserId].time
                                if timeDiff > 0 then
                                    enemyVelocity = (enemyPos - lastPos) / timeDiff
                                end
                            end

                            lastKnownEnemyPositions[enemy.UserId] = {
                                position = enemyPos,
                                time = currentTime
                            }

                            local speed = enemyVelocity.Magnitude
                            local directionToMe = (currentPosition - enemyPos).Unit
                            local enemyDirection = enemyVelocity.Unit

                            local threatLevel = 0

                            if distance < 60 then
                                threatLevel = threatLevel + (60 - distance) * 2
                            end

                            if speed > 16 then 
                                threatLevel = threatLevel + speed * 2
                            end

                            if speed > 5 then
                                local dotProduct = enemyDirection:Dot(directionToMe)
                                if dotProduct > 0.7 then
                                    threatLevel = threatLevel + 50
                                    emergencyMode = true
                                elseif dotProduct > 0.3 then 
                                    threatLevel = threatLevel + 25
                                end
                            end

                            if threatLevel > highestThreat or (threatLevel > 20 and distance < closestDistance) then
                                mostDangerousEnemy = enemy
                                highestThreat = threatLevel
                                closestDistance = distance
                            end
                        end
                    end

                    if mostDangerousEnemy and (highestThreat > 10 or emergencyMode) then
                        local safePosition = findUltimateEscapePosition(currentPosition, mostDangerousEnemy, enemiesWithBombs, currentArena)

                        if safePosition then
                            local moveDistance = (safePosition - currentPosition).Magnitude
                            if moveDistance > 3 then
                                local steps = 8
                                for i = 1, steps do
                                    if not SmartEvasion then break end
                                    local alpha = i / steps
                                    local newPos = currentPosition:Lerp(safePosition, alpha)
                                    humanoidRootPart.CFrame = CFrame.new(newPos, newPos + (safePosition - currentPosition).Unit)
                                    task.wait(0.02)
                                end
                            end

                            if lastSafePos then
                                local moved = (currentPosition - lastSafePos).Magnitude
                                if moved < 2 and (currentTime - stuckCheckTime) > 1 then
                                    humanoidRootPart.CFrame = CFrame.new(safePosition + Vector3.new(0, 2, 0))
                                    stuckCheckTime = currentTime
                                end
                            end
                            lastSafePos = humanoidRootPart.Position
                        end
                    end
                else
                    emergencyMode = false
                    lastKnownEnemyPositions = {}
                end
            end
        end)
    end

    local function startEvasionLoop(EvasionMode)
        if evasionConnection then evasionConnection:Disconnect() end
        if spinConnection then spinConnection:Disconnect() end

        if EvasionMode == "Player Evasion" then
            handlePlayerEvasion()
        elseif EvasionMode == "Go to Up + Spin" then
            goToUpAndSpin()
        end
    end

    local function findLavaInWorkspace(parent)
        local lavaObjects = {}
        
        for _, child in pairs(parent:GetChildren()) do
            if child.Name == "Lava" then
                table.insert(lavaObjects, child)
            end
            
            if #child:GetChildren() > 0 then
                local subLava = findLavaInWorkspace(child)
                for _, lava in pairs(subLava) do
                    table.insert(lavaObjects, lava)
                end
            end
        end
        
        return lavaObjects
    end

    local function copyLavaObject(originalLava)
        local copy = originalLava:Clone()
        copy.Transparency = 1
        copy.Name = "LavaCopy_" .. originalLava.Name .. "_" .. tostring(originalLava:GetDebugId())
        
        local originalPosition = originalLava.Position
        copy.Position = Vector3.new(originalPosition.X, originalPosition.Y + 1, originalPosition.Z)
        
        copy.Parent = workspace
        copy.CanCollide = true
        
        local lavaId = tostring(originalLava:GetDebugId())
        copiedLavaObjects[lavaId] = {original = originalLava, copy = copy}
        lavaDataCache[lavaId] = {
            position = originalPosition,
            size = originalLava.Size
        }
        
        return copy
    end

    local function cleanupCopiedLava()
        for _, lavaData in pairs(copiedLavaObjects) do
            if lavaData.copy and lavaData.copy.Parent then
                lavaData.copy:Destroy()
            end
        end
        
        for _, obj in pairs(workspace:GetChildren()) do
            if obj.Name:find("LavaCopy_") then
                obj:Destroy()
            end
        end
        
        copiedLavaObjects = {}
        lavaDataCache = {}
    end

    local function updateLavaCopy(lavaId, originalLava)
        local lavaData = copiedLavaObjects[lavaId]
        if lavaData and lavaData.copy and lavaData.copy.Parent then
            local newPosition = originalLava.Position
            lavaData.copy.Position = Vector3.new(newPosition.X, newPosition.Y + 3, newPosition.Z)
            lavaData.copy.Size = originalLava.Size
            
            lavaDataCache[lavaId] = {
                position = newPosition,
                size = originalLava.Size
            }
        end
    end

    local function hasLavaChanged(lavaId, currentLava)
        local cachedData = lavaDataCache[lavaId]
        if not cachedData then return true end
        
        local positionChanged = (cachedData.position - currentLava.Position).Magnitude > 0.1
        local sizeChanged = (cachedData.size - currentLava.Size).Magnitude > 0.1
        
        return positionChanged or sizeChanged
    end

    local function startLavaCopyLoop()
        spawn(function()
            while AutoLavaCopy do 
                task.wait(.3)

                if not AutoLavaCopy then break end

                local lavaObjects = findLavaInWorkspace(workspace)
                
                for _, lava in pairs(lavaObjects) do
                    if not AutoLavaCopy then break end

                    local lavaId = tostring(lava:GetDebugId())
                    local alreadyCopied = copiedLavaObjects[lavaId] ~= nil
                    
                    if not alreadyCopied then
                        copyLavaObject(lava)
                    elseif hasLavaChanged(lavaId, lava) then
                        updateLavaCopy(lavaId, lava)
                    end
                end
            end
        end)
    end

    local function disableIce()
        if workspace.Arenas and workspace.Arenas:FindFirstChild("Arena5ICED") then
            local arena = workspace.Arenas.Arena5ICED
            if arena:FindFirstChild("Map") and arena.Map:FindFirstChild("Ice") then
                arena.Map.Ice.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
                WindUI:Notify({
                    Title = "ØªÙ… ØªØ¹Ø·ÙŠÙ„ Ø§Ù„Ø¬Ù„ÙŠØ¯",
                    Content = "Ø§Ù„Ø¬Ù„ÙŠØ¯ Ù…Ø§ Ø±Ø§Ø­ ÙŠØ³Ø¨Ø¨ ØªØ²Ø­Ù„Ù‚",
                    Duration = 3
                })
            end
        end
    end

    -- ========== Ø²Ø± ÙƒØ´Ù Ø¹Ø¯Ùˆ Ø£ÙˆØªÙˆ Ø¨ÙˆÙ…Ø¨ ==========
    Tabs.ProXFeatures:Toggle({
        Title = "Ø§ÙˆØªÙˆ Ø¨Ø§Ø³ Ø¨ÙˆÙ…Ø¨ğŸ’£",
        Desc = "Ø§Ø°Ø§ Ù…Ø¹Ùƒ Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© Ø¨ÙŠØ¹Ø·ÙŠÙ‡Ø§ Ù„ Ø®ØµÙ…Ùƒ",
        Value = false,
        Size = "xlarge",
        Callback = function(state)
            EnemyDetection = state
            if state then
                startEnemyDetectionLoop()
                WindUI:Notify({
                    Title = "ØªÙ… ØªÙØ¹ÙŠÙ„ ÙƒØ´Ù Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡",
                    Content = "",
                    Duration = 3
                })
            else
                if bombLoop then
                    bombLoop = nil
                end
                isUsingBomb = false
                originalPosition = nil
                WindUI:Notify({
                    Title = "ØªÙ… Ø¥ÙŠÙ‚Ø§Ù ÙƒØ´Ù Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡",
                    Content ="",
                    Duration = 3
                })
            end
        end
    })

    -- ========== Ø²Ø± Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù‡Ø±ÙˆØ¨ ==========
    local EvasionMode = "Player Evasion"
    
    Tabs.ProXFeatures:Dropdown({
        Title = "ğŸƒâ€â™‚ï¸ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù‡Ø±ÙˆØ¨",
        Values = {"Player Evasion", "Go to Up + Spin"},
        Value = "Player Evasion",
        Size = "xlarge",
        Callback = function(value)
            EvasionMode = value
            if SmartEvasion then
                startEvasionLoop(EvasionMode)
            end
        end
    })

    -- ========== Ø²Ø± Ù†Ø¸Ø§Ù… Ø§Ù„Ù‡Ø±ÙˆØ¨ Ù…Ù† Ø§Ù„Ù‚Ù†Ø¨Ù„Ø© ==========
    Tabs.ProXFeatures:Toggle({
        Title = "ğŸ›¡ï¸ Ù†Ø¸Ø§Ù… Ø§Ù„Ù‡Ø±ÙˆØ¨ Ù…Ù† Ø§Ù„Ù‚Ù†Ø¨Ù„Ø©",
        Desc = "ÙŠÙ‡Ø±Ø¨ Ù…Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ù„ÙŠ Ø¹Ù†Ø¯Ù‡Ù… Ù‚Ù†Ø¨Ù„Ø©",
        Value = false,
        Size = "xlarge",
        Callback = function(state)
            SmartEvasion = state
            if state then
                startEvasionLoop(EvasionMode)
                WindUI:Notify({
                    Title = "ØªÙ… ØªÙØ¹ÙŠÙ„ Ù†Ø¸Ø§Ù… Ø§Ù„Ù‡Ø±ÙˆØ¨",
                    Content = "Ø¨ÙŠØ¨Ø¯Ø£ Ø¨Ø§Ù„Ù‡Ø±ÙˆØ¨ Ù…Ù† Ø§Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ù„ÙŠ Ø¹Ù†Ø¯Ù‡Ù… Ù‚Ù†Ø¨Ù„Ø©",
                    Duration = 3
                })
            else
                if evasionConnection then evasionConnection:Disconnect() end
                if spinConnection then spinConnection:Disconnect() end
                WindUI:Notify({
                    Title = "ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ù†Ø¸Ø§Ù… Ø§Ù„Ù‡Ø±ÙˆØ¨",
                    Content = "ØªÙˆÙ‚Ù Ù†Ø¸Ø§Ù… Ø§Ù„Ù‡Ø±ÙˆØ¨ Ù…Ù† Ø§Ù„Ù‚Ù†Ø§Ø¨Ù„",
                    Duration = 3
                })
            end
        end
    })

    -- ========== Ø²Ø± FakeLag (ÙÙŠÙƒ Ù„Ø§Ù‚) ==========
    Tabs.ProXFeatures:Button({
        Title = "FakeLag (ÙÙŠÙƒ Ù„Ø§Ù‚)",
        Icon = "wifi-off",
        Size = "xlarge",
        Callback = function()
            -- Ø¥Ø´Ø¹Ø§Ø± ØªÙØ¹ÙŠÙ„
            WindUI:Notify({
                Title = "Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ FakeLag",
                Content = "Ø¨ÙŠØ¸Ù‡Ø± Ù„Ùƒ Ù†Ø§ÙØ°Ø© Ø§Ù„ØªØ­ÙƒÙ…",
                Duration = 3
            })
            
            --// FakeLag System
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local UserInputService = game:GetService("UserInputService")
            local LocalPlayer = Players.LocalPlayer

            --// FakeLag Table
            local FL = {
                enabled = false,
                delay = 2,
                realChar = nil,
                ghost = nil,
                hrp = nil,
                defaultSpeed = nil
            }

            --// Create GUI
            local screenGui = Instance.new("ScreenGui")
            screenGui.Name = "PhantomXFakeLagGUI"
            screenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
            screenGui.ResetOnSpawn = false

            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(0, 250, 0, 150)
            frame.Position = UDim2.new(0.5, -125, 0.5, -75)
            frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
            frame.BorderSizePixel = 0
            frame.Active = true
            frame.Draggable = true
            frame.Parent = screenGui
            Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)

            -- Title
            local title = Instance.new("TextLabel")
            title.Size = UDim2.new(1, 0, 0, 30)
            title.Position = UDim2.new(0, 0, 0, 0)
            title.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
            title.Text = "ğŸ­ PhantomX FakeLag"
            title.Font = Enum.Font.GothamBold
            title.TextSize = 16
            title.TextColor3 = Color3.fromRGB(255, 255, 255)
            title.Parent = frame
            Instance.new("UICorner", title).CornerRadius = UDim.new(0, 8)

            -- Close Button
            local closeBtn = Instance.new("TextButton")
            closeBtn.Size = UDim2.new(0, 30, 0, 30)
            closeBtn.Position = UDim2.new(1, -35, 0, 5)
            closeBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
            closeBtn.Text = "âœ–"
            closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
            closeBtn.Font = Enum.Font.GothamBold
            closeBtn.TextSize = 14
            closeBtn.Parent = frame
            Instance.new("UICorner", closeBtn).CornerRadius = UDim.new(0,5)
            closeBtn.MouseButton1Click:Connect(function()
                screenGui:Destroy()
                FL.enabled = false
            end)

            -- Toggle Button
            local toggleBtn = Instance.new("TextButton")
            toggleBtn.Size = UDim2.new(1, -20, 0, 30)
            toggleBtn.Position = UDim2.new(0, 10, 0, 40)
            toggleBtn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
            toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
            toggleBtn.Font = Enum.Font.Gotham
            toggleBtn.TextSize = 14
            toggleBtn.Text = "ØªØ´ØºÙŠÙ„ Ø§Ù„ÙÙŠÙƒ Ù„Ø§Ù‚"
            toggleBtn.Parent = frame
            Instance.new("UICorner", toggleBtn).CornerRadius = UDim.new(0,5)

            -- Delay Box
            local delayBox = Instance.new("TextBox")
            delayBox.Size = UDim2.new(1, -20, 0, 30)
            delayBox.Position = UDim2.new(0, 10, 0, 80)
            delayBox.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
            delayBox.PlaceholderText = "Ø§Ù„ØªØ£Ø®ÙŠØ± (Ø¨Ø§Ù„Ø«ÙˆØ§Ù†ÙŠ)"
            delayBox.TextColor3 = Color3.fromRGB(255, 255, 255)
            delayBox.Font = Enum.Font.Gotham
            delayBox.TextSize = 14
            delayBox.Text = tostring(FL.delay)
            delayBox.Parent = frame
            Instance.new("UICorner", delayBox).CornerRadius = UDim.new(0,5)

            -- Status
            local status = Instance.new("TextLabel")
            status.Size = UDim2.new(1, -20, 0, 20)
            status.Position = UDim2.new(0, 10, 0, 120)
            status.BackgroundTransparency = 1
            status.Font = Enum.Font.Gotham
            status.TextSize = 12
            status.TextColor3 = Color3.fromRGB(190, 190, 195)
            status.Text = "Ø§Ù„Ø­Ø§Ù„Ø©: Ù…ØªÙˆÙ‚Ù"
            status.Parent = frame

            --// Utility Functions
            local function createGhost()
                if FL.realChar and FL.realChar.PrimaryPart then
                    local success, ghost = pcall(function()
                        return FL.realChar:Clone()
                    end)
                    if success and ghost then
                        for _,desc in ipairs(ghost:GetDescendants()) do
                            if desc:IsA("BasePart") then
                                desc.Anchored = true
                                desc.Transparency = 0.5
                                desc.CanCollide = false
                            elseif desc:IsA("Humanoid") then
                                desc.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                            end
                        end
                        ghost.Parent = workspace
                        FL.ghost = ghost
                    end
                end
            end

            local function removeGhost()
                if FL.ghost then
                    FL.ghost:Destroy()
                    FL.ghost = nil
                end
            end

            local function fakeLagLoop()
                task.spawn(function()
                    while FL.enabled do
                        local char = LocalPlayer.Character
                        local hum = char and char:FindFirstChildOfClass("Humanoid")
                        local hrp = char and char:FindFirstChild("HumanoidRootPart")
                        if not char or not hum or not hrp then
                            task.wait(0.05)
                            continue
                        end

                        -- LAG PHASE: freeze for 0.5 seconds
                        status.Text = "Ø§Ù„Ø­Ø§Ù„Ø©: Ù…ØªØ¬Ù…Ø¯..."
                        hrp.Anchored = true
                        hum.PlatformStand = false
                        task.wait(0.5)

                        -- MOVE PHASE: unfreeze
                        status.Text = "Ø§Ù„Ø­Ø§Ù„Ø©: Ø´ØºØ§Ù„..."
                        hrp.Anchored = false
                        hum.WalkSpeed = FL.defaultSpeed or hum.WalkSpeed
                        local freeTime = math.max(FL.delay - 0.5, 0)
                        local start = tick()
                        while FL.enabled and (tick() - start < freeTime) do
                            task.wait(0.05)
                        end
                    end

                    -- clean reset
                    local char = LocalPlayer.Character
                    local hum = char and char:FindFirstChildOfClass("Humanoid")
                    local hrp = char and char:FindFirstChild("HumanoidRootPart")
                    if hum and FL.defaultSpeed then hum.WalkSpeed = FL.defaultSpeed end
                    if hrp then hrp.Anchored = false end
                    status.Text = "Ø§Ù„Ø­Ø§Ù„Ø©: Ù…ØªÙˆÙ‚Ù"
                end)
            end

            --// Events
            toggleBtn.MouseButton1Click:Connect(function()
                FL.enabled = not FL.enabled
                toggleBtn.Text = FL.enabled and "Ø§ÙŠÙ‚Ø§Ù Ø§Ù„ÙÙŠÙƒ Ù„Ø§Ù‚" or "ØªØ´ØºÙŠÙ„ Ø§Ù„ÙÙŠÙƒ Ù„Ø§Ù‚"
                toggleBtn.BackgroundColor3 = FL.enabled and Color3.fromRGB(255, 60, 60) or Color3.fromRGB(45, 45, 45)

                if FL.enabled then
                    FL.realChar = LocalPlayer.Character
                    if FL.realChar then
                        local hum = FL.realChar:FindFirstChildOfClass("Humanoid")
                        FL.hrp = FL.realChar:FindFirstChild("HumanoidRootPart")
                        if hum then
                            FL.defaultSpeed = hum.WalkSpeed
                        end
                        if FL.hrp then
                            createGhost()
                            fakeLagLoop()
                            status.Text = "Ø§Ù„Ø­Ø§Ù„Ø©: Ø´ØºØ§Ù„..."
                        end
                    end
                else
                    if FL.hrp then FL.hrp.Anchored = false end
                    local char = LocalPlayer.Character
                    local hum = char and char:FindFirstChildOfClass("Humanoid")
                    if hum and FL.defaultSpeed then hum.WalkSpeed = FL.defaultSpeed end
                    removeGhost()
                    status.Text = "Ø§Ù„Ø­Ø§Ù„Ø©: Ù…ØªÙˆÙ‚Ù"
                end
            end)

            delayBox.FocusLost:Connect(function()
                local val = tonumber(delayBox.Text)
                if val and val > 0 then
                    FL.delay = val
                    WindUI:Notify({
                        Title = "ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„ØªØ£Ø®ÙŠØ±",
                        Content = "Ø§Ù„ØªØ£Ø®ÙŠØ± Ø§Ù„Ø¬Ø¯ÙŠØ¯: " .. val .. " Ø«Ø§Ù†ÙŠØ©",
                        Duration = 3
                    })
                else
                    delayBox.Text = tostring(FL.delay)
                end
            end)

            -- Ø²Ø± Ø¥ØºÙ„Ø§Ù‚ Ù…Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
            UserInputService.InputBegan:Connect(function(input, gpe)
                if not gpe and input.KeyCode == Enum.KeyCode.L then
                    toggleBtn:Activate()
                end
            end)

            -- Ø¥Ø¶Ø§ÙØ© Ù†Ø§ÙØ°Ø© FakeLag Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³ÙƒØ±Ø¨Øª
            Window:OnDestroy(function()
                if screenGui then
                    screenGui:Destroy()
                end
                FL.enabled = false
            end)
        end
    })

    -- ========== Ø²Ø± Ù…Ø¶Ø§Ø¯ Ù†Ø§Ø± ==========
    Tabs.ProXFeatures:Toggle({
        Title = "ğŸ›¡ï¸ Ù…Ø¶Ø§Ø¯ Ù†Ø§Ø±",
        Desc = "Ù…Ø¶Ø§Ø¯ Ù„ Ù†Ø§Ø± Ø¨ÙŠÙ…Ù†Ø¹Ùƒ ØªÙˆÙ‚Ø¹",
        Value = false,
        Size = "xlarge",
        Callback = function(state)
            AutoLavaCopy = state
            if state then
                startLavaCopyLoop()
                WindUI:Notify({
                    Title = "ØªÙ… ØªÙØ¹ÙŠÙ„ Ù…Ø¶Ø§Ø¯ Ø§Ù„Ù†Ø§Ø±",
                    Content = "",
                    Duration = 3
                })
            else
                AutoLavaCopy = false
                cleanupCopiedLava()
                WindUI:Notify({
                    Title = "ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¶Ø§Ø¯ Ø§Ù„Ù†Ø§Ø±",
                    Content = "",
                    Duration = 3
                })
            end
        end
    })

    -- ========== Ø²Ø± Ù…Ù†Ø¹ ØªØ²Ø­Ù„Ù‚ ==========
    Tabs.ProXFeatures:Button({
        Title = "ğŸ§Š Ù…Ù†Ø¹ ØªØ²Ø­Ù„Ù‚",
        Icon = "snowflake",
        Size = "xlarge",
        Callback = function()
            disableIce()
        end
    })

    Tabs.ProXFeatures:Divider({Title = ""})

    Tabs.ProXFeatures:Paragraph({
        Title = "ØªÙ†Ø¨ÙŠÙ‡ Ø§Ø³ØªØ®Ø¯Ù… ÙƒÙ„ Ø´ÙŠ Ø¨Ø­Ø¸Ø±",
        Desc = "ÙƒÙ„ Ø´ÙŠ Ø´ØºÙ„Ø© Ø¨Ø­Ø¸Ø± Ø§Ø°Ø§ Ø§Ø­Ø¯ ØµÙˆØ±Ùƒ Ø¨ØªØ¨Ù„Ø¹ Ø¨Ø§Ù†",
        Image = "alert-triangle",
        ImageSize = 28,
        Color = Color3.fromRGB(100, 100, 225)
    })
end
    -- =============================================
    -- ØªØ¨ÙˆÙŠØ¨ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    -- =============================================
    do
        Tabs.Config:Paragraph({
            Title = "Script Settings",
            Desc = "Customize the script to your liking",
            Image = "settings",
            ImageSize = 28,
            Color = "White"
        })

        Tabs.Config:Dropdown({
            Title = "Ø§Ø®ØªØ± Ø§Ù„Ø³Ù…Ø©",
            Values = {"Ø¯Ø§ÙƒÙ† ğŸŒ™", "ÙØ§ØªØ­ â˜€ï¸", "Ø£Ø²Ø±Ù‚ ğŸ”µ", "Ø£Ø®Ø¶Ø± ğŸ’š", "Ø£Ø­Ù…Ø± ğŸ”´"},
            Value = "Ø¯Ø§ÙƒÙ† ğŸŒ™",
            Size = "xlarge",
            Callback = function(value)
                local themeMap = {
                    ["Ø¯Ø§ÙƒÙ† ğŸŒ™"] = "Dark",
                    ["ÙØ§ØªØ­ â˜€ï¸"] = "Light", 
                    ["Ø£Ø²Ø±Ù‚ ğŸ”µ"] = "Sapphire",
                    ["Ø£Ø®Ø¶Ø± ğŸ’š"] = "Emerald",
                    ["Ø£Ø­Ù…Ø± ğŸ”´"] = "Ruby"
                }
                WindUI:SetTheme(themeMap[value] or "Dark")
            end
        })

        Tabs.Config:Button({
            Title = "ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³ÙƒØ±Ø¨Øª",
            Icon = "refresh-cw",
            Size = "xlarge",
            Callback = function()
                WindUI:Notify({
                    Title = "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ­Ø¯ÙŠØ«",
                    Content = "Ø¨ÙŠØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø³ÙƒØ±Ø¨Øª...",
                    Duration = 3
                })
                
                wait(2)
                
                loadstring(game:HttpGet("https://raw.githubusercontent.com/AlphaBay00/Test/main/Faq.txt"))()
            end
        })

        Tabs.Config:Button({
            Title = "Ø£Ù‚ÙÙ„ Ø§Ù„Ø³ÙƒØ±Ø¨Øª",
            Icon = "power",
            Size = "xlarge",
            Callback = function()
                if autoJoinConnection then
                    autoJoinConnection:Disconnect()
                end
                removeArenaESP()
                Window:Destroy()
            end
        })
    end

    -- =============================================
    -- ØªØ¨ÙˆÙŠØ¨ Ø§Ù„Ù…Ø·ÙˆØ±
    -- =============================================
    do
        Tabs.Credits:Paragraph({
            Title = "Cypher",
            Desc = "Roblox Script Developer",
            Image = "user",
            ImageSize = 80,
            Color = Color3.fromHex("#FF6B35")
        })

        Tabs.Credits:Button({
            Title = "Ø§Ù†Ø¶Ù… Ù„Ø³ÙŠØ±ÙØ± Ø§Ù„Ø¯ÙŠØ³ÙƒÙˆØ±Ø¯",
            Icon = "message-circle",
            Size = "xlarge",
            Callback = function()
                setclipboard("https://discord.gg/Mvf8PahjRQ")
            end
        })

        Tabs.Credits:Button({
            Title = "Ø§Ù„Ø¥ØµØ¯Ø§Ø± 2.1.0",
            Icon = "tag",
            Size = "xlarge",
            Callback = function() end
        })

        Tabs.Credits:Button({
            Title = "ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ù…Ø·ÙˆØ±",
            Icon = "mail",
            Size = "xlarge",
            Callback = function()
                setclipboard("cypherclient")
            end
        })
    end

    -- Ø§Ù„ØªÙ†Ø¸ÙŠÙ Ø¹Ù†Ø¯ Ø§Ù„Ø¥ØºÙ„Ø§Ù‚
    Window:OnDestroy(function()
        if speedConnection then speedConnection:Disconnect() end
        if CFloop then CFloop:Disconnect() end
        if autoFollowGUI then autoFollowGUI:Destroy() end
        if autoJoinConnection then autoJoinConnection:Disconnect() end
        
        if fpsBoostActive then
            Lighting.GlobalShadows = true
            settings().Rendering.QualityLevel = Enum.QualityLevel.Automatic
        end
        
        -- ØªÙ†Ø¸ÙŠÙ Ù†Ø¸Ø§Ù… Tebnid
        if EnemyDetection and bombLoop then
            bombLoop = nil
        end
        if SmartEvasion then
            if evasionConnection then evasionConnection:Disconnect() end
            if spinConnection then spinConnection:Disconnect() end
        end
        if AutoLavaCopy then
            cleanupCopiedLava()
        end
    end)

    -- Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„ØªØ±Ø­ÙŠØ¨
    task.wait(4)
    WindUI:Notify({
        Title = "Ø£Ù‡Ù„Ø§Ù‹ ÙˆØ³Ù‡Ù„Ø§Ù‹ ÙÙŠ PhantomXPro ğŸŒŸ",
        Content = "Ø§Ù„Ø³ÙƒØ±Ø¨Øª Ø´ØºÙ‘Ø§Ù„ ÙˆØ¬Ø§Ù‡Ø² Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…!\nØªÙ…ØªØ¹ Ø¨Ù…Ù…ÙŠØ²Ø§ØªÙ†Ø§ Ø§Ù„Ø­ØµØ±ÙŠØ© ğŸš€",
        Duration = 6
    })
else
print("Done") 
end
print(" Done") 